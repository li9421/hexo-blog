{"pages":[],"posts":[{"title":"AJAX","text":"HTTPHTTP (hypertext tranport protocol) 协议 【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则。 是约定，是规则 请求报文重点是格式和参数 12345678行 POST /s?ie=utf-8 HTTP/1.1头 HOST: atguigu.com Cookir: name=guigui Content-type: application/x-ww-from-urlencoded User-Agent: chrome 83 空行体 username=admin&amp;password=admin 响应报文123456789101112行 HTTP/1.1 200 OK头 Content-type： text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 响应代码http响应中常见的几种响应代码 200响应代码 Status Code: 200表示响应成功，很常见 300响应代码 Status Code: 301 表示客户端跳转(重定向）,永久性跳转，一般在servlet 中使用如下代码 12response.setStatus(301);response.setHeader(&quot;Location&quot;,&quot;fail.html&quot;) 302响应代码 Status Code : 302 客户端跳转，临时跳转，比如 访问页面 a.html,提交数据后就会跳转到 b.html 1response.sendRedirect(&quot;/a&quot;); 304 响应代码 Status Code : 304 表示资源未被修改，当不是第一次访问一个静态页面或者图片的时候，就会得到这么一个提示，这是服务端提示浏览器，这个资源没有发生改变，你直接使用上一次下载的就行了，不需要重新下载。这样就节约了带宽，并且浏览器的加载速度也会更快。 404 响应代码 Status Code ：404 表示访问的页面不存在，表示一个浏览器的错误，就是服务端没有提供这个服务，但是你却去访问。一般检查路径问题 500 响应代码 Status Code : 500 表示服务端错误，一般检查servlet。 其他相关代码 100 表示继续 401 表示未授权 402 表示需要付费(很少见) 403 表示禁止 405 表示方法不被允许 406 表示无法请求 (很少见) 408 表示请求超时 413 表示实体过大 (不知道什么意思不用深究) 507 表示存储不足 Ajax1. 原生AJAX1.1 AJAX 简介​ AJAX 全称为 Asynchronous JavaScript And XML 就是异步的JS 和 XML 。 ​ 通过 AJAX 可以在浏览器向服务器发送异步请求，最大的优势： 无刷新获取数据。 ​ AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 1.2 XML 简介​ XML 可拓展标记语言。 ​ XML 被设计用来传输和存储数据。 ​ XML 和 HTML 相似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。 1234567891011比如说我有一个学生：name:&quot;孙悟空&quot;;age =18; gender=&quot;男&quot;用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;但是现在已经被 JSON 取代了用JSON 表示：{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 18,&quot;gender&quot;=&quot;男&quot;} 1.3 AJAX 的特点1.3.1 AJAX的优点 1. 可以无需刷新页面而与服务器进行通信。 2. 允许你根据用户事件来更新部分页面内容 1.3.2 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 1.4 AJAX 的使用1.4.1 核心对象​ XMLHttpRequest: AJAX 是所有操作都是通过该对象进行的。 1.4.2 使用步骤123456789101112131415161718// 1. 创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求信息xhr.open(method.url); // method是求方法 ，get/post 当然还有别的// 可以设置请求头，一般不设置xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');// 3. 发送请求xhr.send(body) // get 请求 不传body 参数 ， 只有 post 请求使用// 4. 接受响应// xhr.responseXML 接受 xml 格式的响应数据// xhr.responseText 接受 文本格式的响应数据xhr.onreadustatechange = function() { if(xhr.readuState == 4 &amp;&amp; sht.status == 200) { var text = xhr.responseText; console.log(text); }} 1.4.3 解决id缓存问题​ 问题： 在一些浏览器(IE) ,由于缓存机制的存在，ajax 只会发生的第一次请求，剩余多次请求不会再发送给浏览器，而是直接加载缓存中的数据。 ​ 解决方式： 浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题 12345678910111213function(){ const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/ie?t=' + Date.now()); // 在url 后面加上参数为当前时间轴，就可以保证每次发送请求的链接都不一样 xhr.send(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { result.innerHTML = xhr.response; } } }} 1.4.4 AJAX 请求状态​ xhr.readyState 可以用来查看请求当前的状态 0 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有调用。 1 表示 send() 方法还没有调用，仍然可以使用 setRequestHeader(),设定 HTTP请求头信息 2 表示send() 方法已经执行，并且头信息和状态码已经收到。 3 表示正在 接受服务器传来的 body 部分数据。 4 表示服务器数据已经完全接收，或者本次接收已经失败 2. jQuery 中的 AJAX2.1 get 请求123456789101112$get(url,[data],[callback],[type])url: 请求的 URL 地址data: 请求携带的参数。callback: 载入成功时的回调函数。type： 设置返回内容的格式， xml。html,script.json text,_default实例 $.get('http://127.0.0.1:8000/jquery-server', { a: 100, b: 200}, function(data) { console.log(data); }, 'json') 2.2 post 请求123456789101112$.post(url, [data], [callback], [type])url:请求的 URL 地址。data:请求携带的参数。callback:载入成功时回调函数。type:设置返回内容格式，xml, html, script, json, text, _default。实例 $.post('http://127.0.0.1:8000/jquery-server', { a: 100,b: 200}, function(data) { console.log(data);}) 2.3 通过方法12345678910111213141516171819202122232425262728 $.ajax({ // url url: 'http://127.0.0.1:8000/jquery-server', // 发送参数 data: { a: 100, b: 200 }, // 请求的类型 type: 'GET', // 响应体结果 dataType: 'json', // 成功的回调 success: function(data) { console.log(data); }, // 失败的回调 error: function() { console.log('出错啦'); }, // 超时时间 timeout: 2000, // 头信息 headers: { c: 300, d: 400, }}) 3. 跨域3.1 同源策略​ 同源策略（Same-Origin Policy）最早是由 Netscape 网景公司提出的,浏览器的一种安全策略。 ​ 同源： 协议、域名、端口号 必须完全相同 ​ 违背同源策略就是跨域。 3.2 如何解决跨域3.2.1 JSONP JSONP是什么 JSONP(JSON with Padding),是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来的，只支持get 请求。 JSONP怎么工作 在网页中有一些标签天生具有跨域能力，比如 img link iframe script. JSONP 就是利用 script 标签 的跨域能力 来发送请求。 JSONP 的使用 动态创建一个 script 标签 var script = doucument.createElement(“script”); 设置 script 的 src ，设置回调函数 script.src = “http://loaclhost:3000/testAjAx?callback=abc&quot;; function abc(data) { ​ alert(data.name); }; 将 script 添加到 body 中 document.body.appendChild(script); 服务器中的路由处理 router.get(“/testAJAX”,function(req,res) { console.log(‘收到请求’) var callback = req.query.callback; var obj = { name:”孙悟空”， age:18 } res.send(callback+”(“+JSON.stringify(obj)+”)”); }) jQuery 中的 JSONP 1234$.getJSON('http://127.0.0.1:8000/jquery-jsonp-server?callback=?',function(data) { $('#xxx').html{ `名称： ${data.name},&lt;/br&gt; 校区： ${data.city}`)}) 3.2.2 CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS [MDN的CORS] CORS 是什么 CORS(Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何操作，完全在服务器中进行处理，支持get 和 post 请求，跨域资源共享标准新增了一组 HTTP 首部字段， 允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 是怎么工作的？ cors 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行 CORS 的使用 主要是 服务器端的设置： 123456router.get(&quot;/testAJAX&quot;,function(req,res){//通过 res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);res.send(&quot;testAJAX 返回的响应&quot;);})","link":"/2021/01/01/AJAX/"},{"title":"前端模块化","text":"为什么要有模块化 webpack认识webpack 什么是webpack 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具 主要两点 模块 打包 前端模块化 ： 前面已经提到过为什么需要模块化 而且也提到了目前前端模块化的一些方案： AMD 、CMD、CommonJS、ES6 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成项目后还需要处理模块间的各种依赖，并且将其进行整合打包。 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在 webpack中都可以被当作模块来使用(在后续我们会看到)。 这就是webpack中的模块化的概念 打包webpack的安装 必须先安装node webpack的起步webpack的配置1webpack ./src/main.js ./dist/bundle.js loader的使用swebpack中配置Vue1. 安装 npm 安装 1npm install vue --save ## 可以指定版本 不需要加 dev 因为运行时也需要 2. 配置Vue在开发是发布了两个版本 runtime-only -&gt; 代码中不可以有任何template runtime-compiler -》 代码中可以有template 因为有compiler 可以用于 编译template ！ 报错 vue-loader有很多版本 从14.之后就需要自己配置一个插件 可以手动改一下版本 改回到13.0.0以上的版本 用 ^13.0.0 plugin的使用插件 对现有的框架进行扩展 搭建本地服务器补充打包设置的抽离 因为开发与运行时配置不同 有的配置开发用 有的配置上线采用 所有需要将其抽离分开","link":"/2021/01/03/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"为什么会有这个网站","text":"或者说，这个网站是怎么来的，主要记录这个网站的搭建过程，记录一下步骤，防止以后忘了。 其实下面的东西全部都可以在官网查到，不知道为什么还要重复写，闲的的吧 这玩意挺麻烦的，主要意义还是在于折腾，如果只是单纯的想存笔记的话，隔壁有道云方便快捷，但是使用体验还是这个好，果然做的多点，体验就好点 使用 HEXO + GithubPages 搭建静态网站1. hexo 介绍1.1 是什么Hexo 是一个基于 Node.js 开发的静态网页生成器，官方说明是博客框架，但是不仅仅可以用于博客，还可用于企业宣传站，产品展示，文本文档等信息展示为主的网站。 1.2 特点 超快速度 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkDown Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至还可以整合Octopress 的大多插件。 一键部署 只需一条指令即可部署到 GitHub Pages，Heroku 或其他平台。 丰富的主题 众多美观，强大的，可定制的主题中，选择；使用任何兼容的模板引擎创建自己的主题 丰富的插件支持 强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具 （Babel,PostCSS LESS/Sass） 轻易集成 2. 起步2.1 安装HexoHexo 依赖 Node.js 和 Git ，所以在安装 Hexo 之前必须确保安装了这两个工具。 2.1.1 安装Node.js就不赘述了，这忘了就是失忆了，去医院吧 2.1.2 安装 Git同上， 留给网址 git 下载 2.1.3 安装Hexo123npm install -g hexo-cli # -g 全局安装hexo --version # 确认版本 2.2 使用 Hexo 生成本地网站在命令行中执行下面的命令来创建网站。 1234hexo init 网站目录名称#例如hexo init my-blog 创建成功的话会生成一个具有下面目录结构的网站项目。 12345678.├── _config.yml 网站配置文件├── package.json 包说明文件├── scaffolds 文章模板目录├── source 源码目录| ├── _drafts 草稿文章目录| └── _posts 发布文章目录└── themes 主题目录 2.3 预览本地网站1npm run server # 这个自己懂的 也可以改 2.4 写文章 创建文章 方式一： 手动创建 方式二：使用命令 hexo new 文章文件名称 写文章 文章配置 语法： YAML Front-matter 文章配置 很重要 开头记得写 可配置项 （https://hexo.io/zh-cn/docs/front-matter） 文章正文 语法： Markdown 编辑工具：推荐Typora 超好用的 2.5 发布 自己搭建服务器 使用第三方云服务 使用第三方网站托管 3. Github PagesGitHub Pages 是 GitHub 提供的一个免费的静态网页托管服务(需要公开仓库才可以，私人仓库使用需要付费，码云好点，但是码云的自动部署需要付费，所以只能选择GitHub) 3.1 注册 GitHub 账户3.2 创建仓库3.3 提交文件3.4 将仓库托管到 GitHub Pages3.5 关于域名3.5.1 GitHub 提供的默认域名 用户名.github.io 用户名.github.io/仓库名称 3.5.2 自定义域名 去买一个域名 在你的域名后台配置 CNAME 到 GitHub 在 GitHub 仓库中添加 CNAME 文件 其中要写入你的自定义域名网址 4 将本地网站部署到 GitHub Pages正确的方式是： 编译构建 将构建结果推送到 GitHub 仓库 开启 GitHub Pages 每次更新都需要重复上面的流程，太过繁琐，不推荐 4.1 GitHub ： 创建仓库4.2 GitHub ： 生成Github 访问 token GitHub 头像下方找到 Settings 找到 Developer Settings 找到 Personal access tokens 点击 Generate new token (文字可能会变，但大概就是这个意思的) 然后给 token 起一个名字，可以随便 但一定 英文 只是注释 然后 勾上 repo 的权限 然后 点击 下面的Generate token 按钮 然后页面就会 生成 一大串长码 注意 这个只会出现一次 记得复制保存好，没有就得重新生成又是不一样的一个 4.3 GitHub ： 将 token 配置到项目的secrets 中 然后打开项目仓库 点击 项目的 Setting 注意是 项目的 上面的是账户的 找到 Secrets 点击 旧版 是 Add a new secret 目前2021.1.3是 New repository secret 然后起一个 name, 虽然可以随便起 但是建议写，ACCESS_TOKEN 否则后面的代码也要改 然后把刚刚复制的长码 填到 Value 点击 Add secret 4.4 本地 : 配置网站根目录本地操作 在 _config.yml 中修改 配置 url 改为 网站的网址 root ： 网站的根路径 如果部署的网址是根路径 则写 / 如果部署的网址是子目录，则这里写 `/子目录/` 4.5 配置 GitHub ACtions在项目中创建，.github/workflows/main.yml并写入以下配置内容 1234567891011121314151617181920212223242526272829303132333435363738name: build and deploy# 当 master 分支 push 代码的时候 触发 workflowon: push: branches: - main # 注意这里是个坑 推送的分支要对 main 和 master容易搞死人jobs: build-deploy: runs-on: ubuntu-latest steps: # 下载仓库代码 - uses: actions/checkout@v2 # 缓存依赖 - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- # 安装依赖 - run: npm ci # 打包构建 - run: npm run build # 发布到 GitHub Pages - name: Deploy uses: peaceiris/actions-gh-pages@v2 env: PERSONAL_TOKEN: ${{ secrets.ACCESS_TOKEN }} # 这里的名字就是 刚刚起的secret，要一样 PUBLISH_BRANCH: gh-pagesPUBLISH_DIR: ./public 在配置 Actions 自动部署时， 总是执行到 Deploy 这一步就会报错，remote: Invalid username or password. fatal: Authentication failed for ‘https://github.com/li9421/hexo-blog.git/'` 就是用户名密码错误 ，无法链接到远程仓库，而该项目是通过 token 来访问仓库的，尝试更新项目的 token 可能可以解决问题，但是时好时坏的，目前推测一个 token 可能是由时效的 但还没有实锤. 目前记录 1.3 号下午 Sun Jan 3 07:00:56 UTC 配置一个 token 到 1.4晚上 23点 Mon Jan 4 15:23:16 UTC 目前还是正常，继续观察 , 1.7晚上 Thu Jan 7 15:28:08 UTC 2021 还是正常,两次都正常。截至 1.9号下午，Sat Jan 9 11:03:14 UTC 还是正常，目测是真的一劳永逸了。 4.6 本地 ： 推送文件到远程仓库1234git init git add .git commit -m &quot;&quot;git push 提交之后要确认的事 查看代码是否提交到线上 查看 GitHub Actions 是否已经开始工作 查看 GitHub Actions 是否工作成功 查看部署之后的网站 4.7 之后怎么更新上面的一些列流程配置好之后，以后作者就只需要 安安静静的写你的博客 （也就是 markdowm）就好了，如果需要更新，只需要使用 git 提交推送项目的源码就可以了，push会自动触发 GitHub Actions 自动构建部署 5. 实践分享 不定期更 5.1 文章图片 本地 source/images 文章资源文件夹 这样方便，但要考虑路径问题啊，文件大小问题啊 在线图床(推荐使用) 新浪已经挂了 用七牛云就是麻烦 需要搞很多事 但是弄好就很方便了 只要把图片上传后 获得一个url 就可以在 markdown中就可以直接引用 5.2 草稿文章5.2.1 默认方式新建草稿文章： 1hexo new draft &lt;title&gt; 预览草稿 ： 1hexo server --draft 将草稿发布为正式文章 1hexo publish [layout] &lt;filename&gt; 5.2.2 hexo-hide-posts 插件5.2.3 折叠文章不希望首页就把文章全部显示 这样会把首页拉的老长 可以使用 1&lt;!-- more --&gt; &lt;!-- more --&gt; 会生成一个 阅读更多的按钮， 后面的内容就不会显示在首页了 5.3 网站主题（https://hexo.io/themes/）这次我们选择的主题是 icarus 中文文档(https://blog.zhangruipeng.me/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/) 5.4 自动部署加自定义域名的问题想要自定义域名 需要在 在根目录放一个 CNAME文件，但是 Actions 自动部署每次都会把文件覆盖掉， 导致域名不会解析。可是配置文件里的url又是自定义的，最终导致两条链接都打不开, 解决方法是 手动在 hexo 根目录下 的 source目录下保存一个 CNAME文件，这要 npm run build 后 public 目录下就会有一个 CNAME文件","link":"/2021/01/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99/"},{"title":"Node.Js","text":"Node.js是什么 Node.js是JavsScript 运行时 通俗易懂的讲，Node.js是JavaScript的运行平台 Node.js既不是语言，也不是框架，它是一个平台 浏览器中的Javascript EcmaScript 基本语法 if var function Object Array Bom Dom Node.js中的javaScript 没用Bom， Dom Ecmascript 在Node中这个javaSript执行环境为javaScript提供了一些服务器级别的API 例如文件的读写 网络服务的构建 网络通信 Http服务 构建于Chrome的V8引擎之上 代码只是具有特定格式的字符串 引擎可以认识它，帮你解析和执行 Googl Chrome的V8引擎是目前公认的解析执行javaScript代码最快的 Node.js的作者把Google Chrome中V8引擎移植出来，开发了一个独立的javaScript运行时环境 Node.js user an envent-driven,non-blocking I/O mode thatmakes it lightweight and efficent. + envent-driven 事件驱动 + non-block I/O mode 非阻塞I/O模型（异步） + ightweight and efficent. 轻量和高效 Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world + npm 是世界上最大的开源生态系统 + 绝大多数的javaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用 + npm install jquery 为什么要学习Node.js 企业需求 具有服务端开发经验更佳 front-end back-end 全栈开发工程师 基本的网站开发能立 + 服务端 + 前端 + 运维部署 多人社区 Node能做什么1+ web服务器后台 命令行工具 npm(node) git(c语言) hexo (node) … 对于前端工程师来讲，接触最多的就是它的命令行工具 自己写的很少，主要是用别人第三方的 webpack gulp npm 起步安装Node环境12+ 查看Node环境的版本号+ 下载 &lt;https://nodejs.org/en/&gt; 安装 傻瓜式安装，一路next 安装过再次安装会升级 确认Node环境是否安装成功 查看 node的版本号： node --version 或者 node -v 配置环境变量 解析执行javaScript1231. 创建编写JavaScript脚本文件2. 打开终端，定位脚本文件所在目录3. 输入 `node 文件名` 执行对应的文件 注意文件名不要用node.js 来命名，也就是说除了node这个名字随便起，最好不要使用中文 文件的读写文件读取： 123456789101112131415161718// 浏览器中的Javascript是没用文件操作能力的// 但是Node中的JanaScript具有文件操作能立// fs是file-system的简写，就是文件系统的意思// 在Node中如果想要进行文件的操作就必须要引入fs这个核心模块// 在fs这个核心模块中，就提供了所有文件操作相关的API// 例如 fs.readFile就是用来读取文件的// 1.使用fs核心模块var fs = require('fs');// 2.读取文件fs.readFile('./data/a.txt',function(err,data) { if(err) { console.log('文件读取失败') }else { console.log(data.toString()) }}) 文件写入： 12345678910// 1.使用fs核心模块var fs = require('fs')// 2.将数据写入文件fs.writeFile('./data/a.txt','我是文件写入的信息内容',function(err,data) { if(err){ console.log('文件写入失败') }else { console.log(data.toString())}) http服务器： 123456789101112131415161718192021222324// 1.加载http核心模块var http = require('http')// 2.使用 http.createServer()创建一个web服务器var server = http.cerateServer();// 3. 服务器要做的事儿/* 提供服务： 对数据服务 发请求 接受请求 处理请求 反馈(发送响应) 当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数*/sever.on('request',function(req.res) { console.log('收到客户端的请求了')})// 4.绑定端口号，启动服务server.listen(3000,function() { console.log('running....')}) Node中的模块系统使用Node编写应用程序主要就是在使用“ EcmaScript语言 和浏览器一样的，但是在Node中没有Bom，Dom 核心模块 文件操作的fs http服务操作的http url路径操作模块 path路径操作模块 os操作系统信息 第三方模块 art-template 必须通过npm下载才可以使用 自己写的模块 自己创建的文件 什么是模块化 文件作用域(模块是独立的，在不同的文件使用必须要重新引用)【在node中没有全局作用域，它是文件模块作用域】 通信规则 加载require 导出exports (e不发音 读 艾克斯破事 ) commonsJS模块规范在Node中Javascript还有一个重要的概念，模块系统 模块作用域 使用require方法来加载模块 使用exports接口对象来导出模块中的成员 加载 require语法 1var 自定义变量名 = require('模块') 作用: 执行被加载模块的代码 得到被加载模块中的 exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有的成员只在当前模块有效 对于希望可以被其他模块访问的成员，我们需要把这些想要公开的成员都挂载到 exports对象中就可以了 导出多个成员（必须在对象中）： 12345678exports.a = 123;exports.b = function() { console.log('bbb')};exports.c = { foo: &quot;bar&quot;};exports.d = 'hello'; 1234导出单个成员（拿到的就是函数，字符串）： ```javascript module.exports = 'hello' 以下情况会覆盖： 12345module.exports = 'hello';// 后者会覆盖前者module.exports = function add(x,y) { return x+y;} 也可以通过以下方法来导出多个成员 123456module.exports = { foo = 'hello', add:function() { return x+y; }}; 12345## 模块原理exports 和 module.exports 的一个引用： console.log(exports === module.exports);// true exports.foo = ‘bar’; // 等价于module.exports.foo = ‘bar’当给expots重新赋值后，exports！=module.exports.最终return的是module.exports,无论exports中的成员是什么都没有用真正去使用的时候： 导出单个成员： exports.xxx = xxx; 导出多个成员： module.exports 或者 module.exports = {}; 123## 总结 // 引用服务var http = require(‘http’);var fs = require(‘fs’);// 引用模板var template = require(‘art-template’);// 创建服务var server = http.createServer();// 公共路径var wwwDir = ‘D:/app/www’;server.on(‘request’,function(req,res) { var url = req.url; // 读取文件 fs.readFile(‘./template-apche.html’,function(err,data) { if(err) { return res.end(‘404 NoT Found’) } fs.readdir(wwwDir,function(err,files) { if (err) { return res.end(‘Can not find www Dir’) } // 使用模板引擎解析替换data中的模板字符串 // 去xmpTempletelist.html中编写模板语法 var htmlStr = template.render(data.toString(),{ title: ‘D:/app/www/ 的索引’, files: files }); // 发送相应数据 res.end(htmlStr) } });server.listen(3000,function() { console.log(‘running’….)})1.jQuery中的each 和 原生JavaScript方法forEach的区别： 提供源头： 原生js是es5提供的（不兼容IE8）， jqurey的each是jQuery第三方库提供的（如果要使用需要用2以下的版本也就是1.版本），它的each方法主要用来遍历jQuery对象（伪数组），同时也可以做低版本forEach的替代品，jQuery的实例对象不可以用forEach方法，如果想要使用必须转为数组([].slice.call(Jquery实例对象)) 才能使用2. 模块中导出多个成员和导出单个成员3.301和302的区别： 301 永久重定向，浏览器会记住(只要不清缓存，下次就直接重定向，不问了) 302 临时重定向 (下次还会再问)4.exports和module.exports的区别： 每个模块中都有一个module对象 module对象中有一个exports对象 我们可以把需要导出的对象都挂载到 module.exports接口对象 也就是module.exports.xxx = xxx的方师傅 但是每次写太多了就很麻烦，所有 Node 为了简化代码，就在每个模块中都提供了一个成员叫exports exports === module.exports结果为 true，所以完全可以exports.xxx = xxx 当一个模块需要导出单个成员的时候必须使用module.exports = xxx的方式， =使用exports = xxx不管用，因为每个模块最后return 的是module.exports,而exports只是module.exports的一个引用，所以exports即使重新赋值，也不会影响module.exports。 有一种赋值方式比较特殊：exports = module.exports这个用来重新建立引用关系。 12345678910111213141516171819202122232425262728293031# require 的加载规则- 核心模块 - 模块名- 第三方模块 - 模块名- 用户自己写的 - 路径## require的加载规则：- 优先从缓存加载- 判断模块标识符 - 核心模块 - 自己写的模块（路径形式的模块） - 第三方模块（node-modules） - 第三方模块的标识就是第三方模块的名称（不可能有第三方模块的核心模块的名字一致） - npm - 开发人员可以把写好的框架库发布到npm上 - 使用者通过npm命令来下载 - 使用方式： var 名称 = require('npm install 【下载包】的包名') 12345- node_modules/express/package.json main- 如果package.json或者main不成立，则查找被选择项： index.js- 如果以上条件都不满足，则继续进入上一级目录中的 node_modules 按照上面的规则依次查找，直到当前文件所属磁盘根目录都找不到最后报错 // 如果非路径形式的标识// 路径形式的标识： // ./ 当前目录 不可省略 // ../ 上一级目录 不可省略 // /xxx 也就是 D：/xxx 也叫磁盘根目录 // 带有绝对路径几乎不用 （D:/a/foo.js）// 首位表示的是当前文件模块所属磁盘根目录// requir(‘./a’); // 核心模块// 核心模块本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了require(‘fs’); // 第三方模块// 凡是第三方模块都必须通过npm下载(npm i node_modules),使用的时候就可以通过require(‘包名’)来加载使用// 第三方包的名字不可能和核心模块的名字是一样的// 既不是核心模块，也不是路径形式的模块// 先找到当前文件所属目录的node_modules// 然后找node——modules/art-template目录// mode_modules/art-template/package.json// node_modules/art-template/package.json中的main属性// main属性记录了art-template的入口模块// 然后就使用加载这个第三方包// 实际最终加载的还是文件 // 如果package.json不存在或者main 指定的入口模块不存在// 则node会自动找该目录下的index.js// 也就是说index.js 是一个备选项，如果main没有指定，就加载index.js//// 如果条件都不满足则会进入上一级目录进行查找// 注意： 一个项目只有一个node_modules,放在项目根目录中，子目录可以直接调用根目录的文件var template = require(‘art-temolate’) 12345## 模块标识符中的/和文件操作路径中的/文件操作路径： // 咱们所使用的所有文件操作的APi都是异步的// 就像AJAX请求一样// 读取文件// 文件操作中 ./相当于当前模块所处的磁盘根目录// ./index.txt 相对于当前目录// /index.txt 相对于当前目录// /index.txt 绝对路径，当前文件模块所处根目录// d:/express/index.js 绝对路径fs.readFile(‘./index.txt’,function(err,data) { if(err){ return consloe.log(‘读取失败’) } console。log(data.toString());}) 123模块操作路径 // 在模块加载中，相对路径中的./不能省略// 这里省略了，也是磁盘根目录require(‘./index’)(‘hello’) 123456789101112131415161718# npm- node package manage(node包管理器)- 通过npm命令安装jQuery包（npm install --save jquery),在安装时加上 --save 会主动生成说明文件信息（将安装文件的信息添加到package.json里面 npm 5.版本后可以省略 --save 不管加不加都会自动保存）### npm 网线&gt; [npmjs.com](http://npmjs.com/) 网站 是用来搜索npm包的### npm命令行工具npm是一个命令行工具，只要安装了node就可以安装npmnpm 也有版本概念，可以通过 `npm --version`来查看npm的版本升级npm（自己升级自己）： npm install –global npm 123456789101112131415161718192021222324252627282930### 常用命令- npm init(生成package.json说明书文件） - npm init -y(可以跳过向导，快速生成)- npm install - 一次性把dependencies 选项中的依赖项全部下载 - 简写 （npm i）- npm install 包名 - 只下载 - 简写 （npm i 包名）- npm install --save - 下载并保存依赖项 （package,json文件中的dependencies） - 简写 （npm i 包名）- npm uninstall 包名 - 只删除，如果有依赖项会保存 - 简写 （npm un 包名）- npm help - 查看使用帮助- npm 命令 -- help - 查看具体命令的使用帮助 （npm uninstall--help）### 解决npm被墙问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以需要解决这个问题。&gt; https://developer.aliyun.com/mirror/NPM?from=tnpm 淘宝开发团队把npm 在国内做了一个镜像 (也就是一个备份)。安装淘宝的cnpm npm install -g cnpm – registry=https://registry.npm.taobao.org#在任意目录执行都可以 –global表示安装到全局，而非当前目录–global不可以省略，否则不管用npm install –global cnpm 123安装包的时候把以前的`npm`替换成`cnpm`。 走国外的npm 服务器下载jQuery包，速度比较慢npm install jQuery； 使用cnpm 就会通过淘宝的服务器来下载jQuerycnpm install jQuery 123如果不想安装 cnpm 又想使用淘宝的服务器来下载： npm install jquery –registry=https://npm.taobao.org; 123但是每次手动加参数就很麻烦（主要记不住），所以我们可以把这个选项加入到配置文件中： npm config set registry https://npm.taobao.org; 查看npm配置信息npm config list; 123456789只要经过上面的配置命令，则以后所有的`npn install`都会通过淘宝的服务器来下载# package.json每个项目都要有一个`package.json`文件（包描述文件，就像产品是说明书一样）这个文件可以通过 `npm init`自动初始化出来 PS D:\\code\\node&gt; npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults. See npm help init for definitive documentation on these fieldsand exactly what they do. Use npm install &lt;pkg&gt; afterwards to install a package andsave it as a dependency in the package.json file. Press ^C at any time to quit.package name: (node)version: (1.0.0)description: 这是一个测试项目entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to D:\\code\\node\\package.json: { “name”: “node”, “version”: “1.0.0”, “description”: “这是一个测试项目”, “main”: “index.js”, “scripts”: { “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”} Is this OK? (yes) yes 12345678910111213141516171819202122对于目前来讲，最有用的是`dependencies`选项，可以用来帮助我们保存第三方包的依赖信息。如果`node_modules`删除了也不用但是，只需要在控制面板中`npm install`就会自动把`package.json`中的`dependencies`中所有的依赖项全部下载下来。- 建议每个项目的根目录下都有一个`package.json`文件- 建议执行`npm install 包名`的时候都加上`--save`选项，目的是用来保存依赖信息## package.json和package-lock.jsonnpm 5 以前是不会有`package-lock,json`这个文件npm 5 以后才加入这个文件当你安装包的时候，npm都会生成或者更新`package-lock.json`这个文件- npm5以后的版本都不要加 `--save`参数，它会自动保存依赖信息- 当你安装包的时候，自动创建或者更新`package.json`文件- ``` package-lock.json 这个文件会包含 1node_modules 中所有包的信息（版本，下载地址。。。） 这样的话重新npm install的时候速度就可以提升 从文件来看，有一个 1lock 称之为锁 这个lock是用来锁版本的 如果项目依赖了1.1.1版本 如果你重新install 其实会下载 最新版本，而不是1.1.1 package-lock.json的另一个作用就是用来锁定版本号，防止自动升级 path路径操作模块 参考文档：https://nodejs.org/docs/latest-v13.x/api/path.html path.basename: 获取路径的文件名，默认包含拓展名 path.dirname: 获取路径中的目录部分 path:extname: 获取一个路径中的拓展名部分 patn.parse: 把路径转为对象 root:根路径 dir：目录 base： 包含拓展名的文件名 name： 不包含后缀名的文件名 path.join: 拼接路径 path.isAbsolute: 判断一个路径是否为绝对路径（图片丢失） Node中的其他成员(dirname,filename)在每个模块中，除了require,exports等模块相关的API之外，还有两个特殊的成员： __dirname,是一个成员可以用来动态获取当前文件模块所属目录的绝对路径 __filename,可以用来动态获取当前文件的绝对路径(包含文件名) __dirname和__filename是不受node命令所属路径影响的 [图片丢失] 在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node 命令所处的路径 所以为了解决这个问题，只需要把相对路径改为绝对路径(绝对路径不受任何影响)就可以了 就可以使用__dirname 或者__filename来帮助我们解决这个问题 在路径拼接的过程中，为了避免手动拼接带来的一些低级错 推荐使用 path.join()`来辅助拼接 1234567891011var fs = require('fs');var path =require('path');// console.log(__dirname + 'a.txt');// path.join方法会将文件操作中的相对路径都统一的转为动态的绝对路径fs.readFile(path.join(__dirname + '/a.txt'),'utf-8',function(err,data) { if (err){ throw err } console.log(data);}); 补充： 模块中的路径标识和这里的路径没有关系，不受影响(就是相对于文件模块) 注意：模块中的路径标识和文件操作中的相对路径标识不一致 模块中的路径标识就是相对于当前文件模块，补受node命令所处路劲影响 修改完代码自动重启我们在这里可以使用一个第三方命令行工具： nodemon来帮助我们解决频繁修改代码重启服务器的问题。 nodemon是一个基于Node.js开发的第三方命令行工具，我们使用的时候需要独立安装； 1234567# 在任意目录执行该命令都可以# 也就是说，所有需要 --global 安装的包都可以在任意目录执行npm install ---global nodemonnpm install -g nodemon# 如果安装不成功的话 ，可以使用cnpm 安装cnpm install -g nodemon 安装完毕之后使用： 1234node app.js# 使用nodemonnodemon app.js 只要是通过nodemon启动服务，则他会监视你的文件变化，当文件发生变化的时候，会自动帮你重启服务器。","link":"/2021/01/09/Node%E4%BB%8B%E7%BB%8D/"},{"title":"Express","text":"作者：Tj 原生的http在某些方面表现不足以应对我们的开发需求，所以就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。 在node中有很多web开发框架。主要学习express http://expressjs,com其中主要封装的是http。 123456789101112131415161718192021222324// 1.安装// 2.引包var express = require('express')var path = requre('path')// 3.创建服务器应用程序// 也就是原来的http.createServer();var app = express();// 公开指定目录// 只要通过这样做了，就可以通过/public/xx的方式来访问public目录中的所有资源// 在Express中开放资源就是一个Api的事app.use('/public',express.static(path.join(__dirname,'/public')));// 模板引擎在Express中开放模板也是一个API的事// 当服务器收到get请求 / 时候，执行回调函数app.get('./',function(req,res) { res.send('hello,express')})// 相当于server.listenapp.listen(300,funcction(){ console.log('app is running at port 3000');})学习Expres 学习Express起步安装：[图片丢失] 1cnpm install express hello world: 【图片丢了】 1234567891011121314151617181920212223// 引入 expressvar express = require('express')// 1.创建 appvar app = express();// 2.app.get('/',function(req,res) { // 1. // res.write('Hello'); // res,weite('World'); // res.end() // 2 // res.end('hello wrold') // 3 res.send('hello world')})app.listen(3000,function() { console.log('express app is runing...')}) 基本路由路由： 请求方法 请求路径 请求处理函数 get: 1234// 当你以get方法请求/的时候，执行对应的处理函数app.get('/',function(req,res){ res.send('hello world')}) post: 1234// 当你以post方法请求/的时候，执行对应的处理函数app.post('/',function(req,res) { res,send('hello world')}) Expresss静态服务api123456// app.use不仅仅用来处理静态资源的，还可以做很多工作（body-parser的配置等等）app.use(express.static('public'));app.use(express.static('files'));app.use('/static',express.static('public')); 123456789101112131415161718192021222324252627// 引入express var express = require('express')// 创建appvar app = express();// 开放静态资源// 1.当以//public/开头的时候，去./public/目录中找对应的资源// 访问： http://127.0.0.1:3000/public/login.htmlapp.use('/public/',express.static(patn.join('__dirname','/public/')))// 2.当省略第一个参数的时候，可以通过省略/public的方式来访问// 访问： http:/127.0.0.1:3000/login.html// app.use(express.static('./public/'));// 3.访问： http://127.0.0.1:3000/a/logi.html// a 相当于public的别名// app.use('/a/',express.static('./public/'));// app.get('/',function(req,res) { res.end('hello world');});app.listen(3000,function(){ console.log('express app is running')}) 在Express中配置使用art-template模板引擎 art-template官方文档 在node中，有很多第三方模板引擎都可以使用有art-template 还有ejs，jade（pug），handlebars，nunjucks 安装： 12345npm install --save art-templatenpm install --save express-art-template// 两个一起安装npm i --save art-template express-aet-template 配置： 1app.engine('html',require('express-art-template')); 使用： 123456app.get('/',function(req,res) { // express默认会去views目录找index.html res.render('index.html',{ title:'hello world' });}) 如果希望修改默认的 views 视图渲染存储目,可以” 123// 第一个参数千万不要写错app.set('views',目录路径)// 一般不要去改 就使用views 是一种约定 在Expresss中获取表单请求路径获取get请求数据：Express内置了一个API，可以直接通过req.query来获取数据 123// 通过req.query 方法获取用户请求输入的数据// req.query只能拿到get请求的数据var comment = req.query; 获取post请求数据：在Express中没有内置获取表单的post请求体的api，这里我们需要使用一个第三方包的body0parser来获取数据 安装： 1npm install --save body-parser 配置： // 配置解析表单 POST 请求体插件（注意 一定要在app.use(router)之前） 1234567891011121314const express = require('express')// 引包const bodyParser = require('body-parser')const app = express()// 配置body-parser// 只要加入这个配置，则在req的请求对象上会多出来属性： body// 也就是说可以直接通过 req.body 来后去表单post请求数据// parser application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({ exrended: false}))// parse application/jsonapp.use(bodyParser.json()) 使用： 123456app.use(function(req,res) { res.setHeader('Comtent-type','text/plain') res.write('you posted:\\n') // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2))}) 在Express中配置使用express-session插件操作 参考文档：https://github.com/expressjs/session 安装： 1npm install express-session 配置： 1234567891011// 该插件会为req请求对象添加一个成员： req.session默认是一个对象// 这是最简单的配置方式// Session是基于 cookie 实现的app.use(session({ // 配置加密字符串，他会在原有的基础上和字符串拼接起来去加密 // 目的是为了增加安全性，防止客户端恶意伪造 secret: 'keyboard cat', resave: false, saveUninitialized: true, // 无论是否适用Session，都默认直接分配一把钥匙 cookie: { secure: true}})) 使用： 123456789101112// 读// 添加 Session 数据// session就是一个对象req.session.foo = 'bar';// 写// 获取 session 数据res.session. foo// 删req.session.foo = null;delete req.session.foo 提示： 默认Session 数据是内存储数据，服务器一旦重启，真正的生产环境会把Session进行持久化存储。 利用Express实现ADUS项目模块化思想模块化如何划分： 模块职责要单一 JavaScript模块化： Node中的 CommonsJS 浏览器中的： AMD require.js CMD sea.js es6中增加了官方支持 起步 初始化 模板处理 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit 处理编辑请求 GET /students/dalete id 处理删除请求 提取路由模块router.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** router.js路由模块职责： 处理路由 根据不同的请求方法+请求路径涉资具体的请求函数 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提高开发效率*/var fs =requires('fs');// Express 专门 提供了一种更好的方式// 专门提供路由的var express = require('express');// 1.创建一个路由容器的var router = express.Router();// 2. 把路由都挂载到路由容器中router.get('/students',function(req,res){ // res.send('hello world'); // readFile的第二个参数是可选的，传入utf-8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符串 // 除了这样来转换，也可以通过data。toString（）来转换 fs.readFile('./db.json','utf8',function(err,data) { if(err) { return res.status(500).send('Server error.') } // 读取到的文件数据是string类型的数据 // console.log(data); // 从文件按中读取到的数据据一定是字符串，所以一定要手动转化成对象 var students = JSON.parse(data).students; res.render('index.html',{ // 读取文件数据 students: students }) }) })router.get('/students/new',function(req,res) { res.render('new.html')});router.get('\\students/edit',function(req,res) { })router.post('/students/edit',function(req,res) { })// 3.把router导出module.exports = router; app.js: 123456var router = require('./router')// router(app);// 把路由容器挂载到app服务中// 挂载路由app.use(router); 设计操作数据的API文件模块es6中的find和findindex： find接收一个方法作为参数，方法内部返回一个条件 find会遍历所有的元素，执行你给定的带有条件返回值的函数 符合该条件的元素会作为find方法的返回值 如果遍历结束还没有符合该条件的元素，则返回undefined(图片丢了) 123456789101112131415161718192021222324252627282930313233343536/**student.js 数据操作模块职责： 操作文件中的数据，只处理数据，不关心也业务*/const fs = require('fs');/**获取所有学生列表return【】*/exports.find = function() { }/*** 获取添加保存学生*/expors.savr= function() { }/*** 更新学生*/exports.undate = function() { }/*** 删除学生*/exports.delete = function() { } 步骤 处理模板 配置静态开放资源 配置模板引擎 简单的路由，/studens渲染静态页出来 路由设计 提取路由模块 由于接下来一系列业务操作都需要处理文件数据，所有我们需要封装Student.js 先学好students.js文件结构 查询所有学生列别的API findById save updateByid daleteid 实现具体功能 通过路由收到请求 接受请求中的参数（get，post） req.query req.body 调用数据操作API处理数据 根据操作结果给客户端发送请求 业务功能顺序 列表 添加 编辑 删除 子模版和模板的继承（模板引擎高级语法）【include，extend，block】注意： 模板页 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;模板页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;/&gt; {{ block 'head' }}{{ /block }}&lt;/head&gt;&lt;body&gt; &lt;!-- 通过include导入公共部分 --&gt; {{include './header.html'}} &lt;!-- 留一个位置 让别的内容去填充 --&gt; {{ block 'content' }} &lt;h1&gt;默认内容&lt;/h1&gt; {{ /block }} &lt;!-- 通过include导入公共部分 --&gt; {{include './footer.html'}} &lt;!-- 公共样式 --&gt; &lt;script src=&quot;/node_modules/jquery/dist/jquery.js&quot; &gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot; &gt;&lt;/script&gt; {{ block 'script' }}{{ /block }}&lt;/body&gt;&lt;/html&gt; 模板的继承： header页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的头部&lt;/h1&gt;&lt;/div&gt; footer页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的底部&lt;/h1&gt;&lt;/div&gt; 模板页的使用： 12345678910111213141516171819202122232425&lt;!-- 继承(extend:延伸，扩展)模板也layout.html --&gt;&lt;!-- 把layout.html页面的内容都拿进来作为index.html页面的内容 --&gt;{{extend './layout.html'}}&lt;!-- 向模板页面填充新的数据 --&gt;&lt;!-- 填充后就会替换掉layout页面content中的数据 --&gt;&lt;!-- style样式方面的内容 --&gt;{{ block 'head' }} &lt;style type=&quot;text/css&quot;&gt; body{ background-color: skyblue; } &lt;/style&gt;{{ /block }}{{ block 'content' }} &lt;div id=&quot;&quot;&gt; &lt;h1&gt;Index页面的内容&lt;/h1&gt; &lt;/div&gt;{{ /block }}&lt;!-- js部分的内容 --&gt;{{ block 'script' }} &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt;{{ /block }} 最终结果：【图片丢了】 Express中间件中间件的概念 参考文档：http://expressjs.com/en/guide/using-middleware.html 【图片丢失】 中间件： 把很复杂的事情分割成单个，然后依次有条理的执行。就是一个中间处理环节，有输入，有输出。 说的通俗易懂点儿，中间件就是一个（从请求到响应调用的方法）方法。 把数据从请求到响应分步骤来处理，每一个步骤就是一个中间处理环节。 123456789101112131415161718192021222324252627var http = require('http');var url = require('url');var cookie = require('./expressPtoject/cookie');var query = require('./expressPtoject/query');var postBody = require('./expressPtoject/post-body');var server = http.createServer(function(){ // 解析请求地址中的get参数 // var obj = url.parse(req.url,ture); // req.query = obj.query; query(req,res); // 中间件 // 解析请求地中中的post参数 req.body = { foo:'bar' }});if (req.url === 'xxx') { // 处理请求 。。。 }server.listen(3000,function(){ console.log('3000 running');}); 同一个请求对象所经过的中间件都是同一个请求对象和响应对象。 123456789101112131415161718192021const express = require('express');const app = exprss();app.get('/abc',function(req,res,next) { // 同一个请求的req和res 是一样的， // 可以前面存储下面调用 console.log('/abc'); // req.foo = 'bar'; req.body = { name: 'xiaoxiao', age: 18 } next();});app.get('/abc',function(req,res,next){ // console.log(req,foo) console.log(req.body); console.log('/abc');});app.listen(3000,function() { console.log('app is running at port 3000.')} 【图片丢失】 中间件的分类：应用程序级别的中间件万能匹配（不关心任何请求路径和请求方法的中间件）: 1234app.use(function(req,res,next){ console.log('Time',date.now()); next()}); 关心请求路径和请求方法的中间件： 1234app.use('/a',function(req,res,next){ console.log('Time',Date.now()); next();}); 路由级别的中间件严格匹配请求路径和请求方法的中间件 get： 123app.get('/',function(req,res) { res.send('get'); }); post： 123app.post('/a',function(req,res) { res.send('post')}) put: 123app.put('/user',function(req,res){ res.send('put') }) dalete: 123app.delete('/dalete',function(req,res){ res.send('delete') }) 总123456789101112131415161718192021222324252627282930313233343536373839const express = require('express')const app = express();// 中间件 ： 处理请求，本质就是个函数// 在express 对中间件有几种分类// 1.不关心任何请求路径和请求方法的中间件// 也就是说任何请求都会进入这个中间件// 中间件本身是一个方法，该方法接受三个参数// Request 请求对象// response 响应对象// next 下一个中间件// // 全局匹配中间件// app.use(function(req,res,next){// console.log('1')''// })// 当一个请求进入中间件后；// 如果需要请求另一个方法则需要使用next()方法// next（）；// next 方法是一个方法，用来调用下一个中间件// 注意 next（）方法调用下一个方法的时候，也会匹配（不是调用紧挨着的哪一个）// app.use(function(req,res,next){consolg.log('2');});// 2.关心请求路径的中间件// 以/xxx开头的中间件// app.use('/a',function(req,res,next) {console.log(req.url);})// 3.严格匹配请求路径和请求方法的中间件app.get('/',function(){ console.log('/');});app.post('/a',function() { console.log('/a')});app.listen(3000,function(){ console.log('app is running au port 3000')}); 错误处理中间件12345app.use(function(err,req,res,next) { console.error(err,stack); res.statu(500).send('Someting broke');}); 配置使用404 中间件： 123app.use(function(req，res) { res.render('404.html')}); 配置全局错误处理中间件： 1234567891011121314151617app.get('/a',function(eq,res,next) { fs.readFile('.a/bc',function(err) { if (err) { // 当调用next()传参后，则之间进入全局错误处理中间件方法中 // 当发生全局错误的时候，我们可以调用next传递错误对象 // 然后被全局错误处理中间件匹配到并进行处理 next(err); } })});// 全局错误处理中间件app.use(function(err,req,res,next) [ res.status(500).json({ err_code: 500, message: err.message });]); 内置中间件 express.static（提供静态文件） http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express 第三方中间件 参考文档：http://expressjs.com/en/resources/middleware.html body-parser compression cookie-parser mogran response-time server-static session 更换头像功能引入插件 multer 参考链接 https://juejin.im/entry/6844903763937853453 multer 文档：https://github.com/expressjs/multer 按照1npm install --save multer 引包+配置中间件123456789101112131415161718192021222324252627282930313233343536373839404142var express = require('express')var multer = require('multer')// var upload = multer({ dest: 'uploads/' }) // 设定上传文件存放位置 但是这个设置太简单不好用// 这个设置 比较好用 var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, 'public/img') // 设置文件存放位置 相对程序启动目录位置 }, filename: function (req, file, cb) { cb(null, Date.now() + file.originalname) // 设定文件拓展名 一定要设置才能使用这张图片 }})var upload = multer({ storage: storage })var app = express()// 上传单张图片，并指定上传时input的name为avatarapp.post('/profile', upload.single('avatar'), function (req, res, next) { // req.file 对象类型，包含上传文件的基本信息 // req.body 将具有文本域数据，如果存在的话})// 上传12张图片，指定上传时input的name为photosapp.post('/photos/upload', upload.array('photos', 12), function (req, res, next) { // req.files 数组类型，包含多个file // req.body 将具有文本域数据，如果存在的话})var cpUpload = upload.fields([{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }])app.post('/cool-profile', cpUpload, function (req, res, next) { // req.files 是一个对象 (String -&gt; Array) 键是文件名，值是文件数组 // // 例如： // req.files['avatar'][0] -&gt; File // req.files['gallery'] -&gt; Array // // req.body 将具有文本域数据，如果存在的话}) 案例 1234567891011121314151617181920212223242526272829// 接受客户上传头像router.post('/settings/profile/pic_upload', upload.single('avatar'), function(req, res, next) { console.log(req.file); // req.session.user.avatar = '/public/img/' + req.file.filename User.findOneAndUpdate(req.session.user._id, { avatar: '/public/img/' + req.file.filename // 将文件名替换掉数据库存储的默认文件名或者上一个文件名 }, function(err, data) { if (err) { return next(err) } User.findOne({ email: data.email }, function(err, data) { if (err) { return next(err) } req.session.user = data res.status(200).json({ err_code: 0, message: 'ok', imgurl: data.avatar // 将图片路径传给前端，用来改变田端的图片显示 }) }) }) // res.redirect('/settings/profile')}) 前端上传头像写法【重要】form 表单直接提交写法 123456&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; form 表单提交需要加enctype=&quot;multipart/form-data&quot;，确保Content-Type是multipart/form-data JQuery 异步提交12345678910111213141516171819202122232425&lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;fileUploader&quot;&gt;&lt;button onclick=&quot;uploadFile()&quot;&gt;上传&lt;/button&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery/3.1.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function uploadFile () { var formData = new FormData(); var file = document.getElementById('fileUploader').files[0]; // 这里指定name值，input指定的name不起作用 formData.append('avatar', file); $.ajax({ url : '/profile', type : 'post', data : formData, // processData 默认true，会将data转化为string传输，这里必须设置为false processData: false, // contentType 默认'application/x-www-form-urlencoded; charset=UTF-8' // 这里不要设置为multipart/form-data，会丢失部分信息，设置为false，会自动识别contentType contentType: false, success : function (res) { console.log(res);// 最好这里返回一个路径 直接替换掉 目标元素的src属性 }, }) }&lt;/script&gt;","link":"/2021/01/11/Express/"},{"title":"webpack","text":"认识webpackwebpack官网 (纯英文的可能看不懂) webpack中文网 什么是webpack 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具 主要两点 模块 打包 前端模块化 ： 前面已经提到过为什么需要模块化 而且也提到了目前前端模块化的一些方案： AMD 、CMD、CommonJS、ES6 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成项目后还需要处理模块间的各种依赖，并且将其进行整合打包。 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在 webpack中都可以被当作模块来使用(在后续我们会看到)。 这就是webpack中的模块化的概念 打包:打包如何理解呢？ 理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系的后，打包的概念就非常好理解了。 就是将webpack中的各种资源合并成一个或多个包（Bundle） 并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss/less等转成css，将ES6语法转成ES5语法，将typescrip转成JavaScript等等操作 但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢 webpack的安装 必须先安装Node.JS npm 全局安装 webpack 1npm install webpack@3.6.0 -g ## 这里指定3.6.0版本因为vue cli2依赖该版本 局部安装webpack --save-dev 指开发时依赖，项目打包后不需要继续使用的。 12cd 对应目录npm install webpack@3.6.0 --save-dev 为什么全局安装后还需要局部安装？ 在终端直接执行webpack命令，使用的全局安装的webpack 当在package.json中定义了scripts 时，其中包含webpack 命令，那么使用的是局部webpack 为避免全局与局部配置版本不同等，建议使用当前局部安装webpack打包当前的代码资源 webpack的起步准备工作： 创建如下文件和文件夹 文件和文件夹解析： dist 文件夹： 用于存放打包后的文件 src 文件夹： 用于存放我们写的源文件 main.js : 项目的入口文件。具体内容查看详情 index.html : 浏览器打开展示的首页html package.json ： 通过npm init 生成的，npm包管理的文件 JS文件的打包现在的js文件中使用了模块化的方式进行打包，但是不可以直接使用 因为如果直接在index.html引入这些js文件，浏览器并不能识别其中的模块化代码 另外，在真实的项目中会有很多这样的js文件，我们一个一个引用非常麻烦，并且后期非常不方便对他们进行管理。 应该使用 webpack 工具 对多个js文件进行打包 我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。(具体原理看后面) 另外，如果在处理完所有模块之间的关系后，将多个js文件打包到一个js文件中引入就方便很多了 webpack 打包指令 1webpack src/main.js dist/bundle.js 打包后会在dist 文件下 生成一个 bundle.js文件 文件很复杂 基本可以不看 bundle.js文件是webpack 处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可 webpack的配置1webpack ./src/main.js ./dist/bundle.js 入口和出口我们考虑到：如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一个中方法可以将这个两个函数参数写道配置中，在运行的时候直接读取 webpack配置方法 创建一个webpack.json文件 1234567891011const path - requre('path') // 引入node 默认模块moudule.exprots = { // 入口： 可以是字符串/数组/对象，这里文明入口只有一个，所有写一个字符串及可 entry: './src/main.js', // 出口，通常是一个对象，里面至少包含两个重要属性，path 和 filename output:{ path: path.resolve(__dirname,'dist'),// 注意 path通常是一个绝对路径 filename: 'bundle.js' }} 局部安装webpack目前，我们使用的webpack是全局的webpack，如果我们想局部打包 因为一个项目往往依赖特定的webpack版本，全局的版本可能和这个项目的webpack版本不一致，导致打包出现问题 通常一个项目都有自己局部的webpack。 第一步，项目中需要安装自己局部的webpack 这里我们让局部安装webpack3.6.0 Vue CLi3中已经升级到了webpack4 但是它将配置文件隐藏起来了，所以查起来不是很方便。 1npm install webpack@3.6.0 --save-dev 第二步，通过node_modules/.bin/webpack启动webpack打包package.json中定义启动由于上面启动方式太麻烦，我们可以在package.json的scripts中定义自己的执行脚本 package.json中的scripts脚本在实行时，会按照一定的顺序寻找命令对应的位置 首先，会先寻找本地的node_modules/.bin路径中对应的命令 如果没有找到，会去全局的环境变量中寻找 如果执行我们的build指令 1npm run build loader的使用什么是loaderloader是webpack中一个非常核心的概念 webpack用来做什么呢？ 在我们之前的实例中，我们主要用webpack 来处理我们写的js代码，并且 webpack 会自动处理js之间相关的依赖。 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css，图片，也包括一些高级的将ES6转成ES5代码，将Typescript转成JavaScript，将scss、less转成css，将.jsx、.vue文件转成js文件等等。 但是对于webpack本身来说，对于这些转化是不支持的。 那怎么办呢? 给webpack拓展对应的loader就可以啦 loader使用步骤： 步骤一： 通过npm 安装需要使用的loader 步骤二：在webpack.config.json中的modules 关键字下进行配置 大部分的loader我们都可以在webpack的官网中找到，并且学习对应的用法。 css文件处理准备工作项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中 在src目录中，创建一个css 文件，其中创建一个normal.css文件 我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。 在入口文件中引用 123// main.jsrequire('对应的位置/css/normal.css')// 然后重新打包 此时就会报错 告诉我们需要有对应的loader css-loader在webpack官网中， 可以找到关于样式的loader使用方法 1npm install --save-dev css-loader ## 安装 css-loader webpack.config.json 1234567891011module.exports = { module: { // 在rules 这个数组里配置 loader rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ] }} 按照官方配置的webpack.config.json,会发现有一个style-loader。 style-loader除了css-loader 我们还需要一个style-loader 1npm install --save-dev style-loader ## 安装 配置 webpack.config.json 1234567891011module.exports = { module: { // 在rules 这个数组里配置 loader rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] // css 和 style的位置固定 } ] }} 其中 css-loader 是用来解析 css 文件的 style-loader 是用来将样式添加到DOM中的 但是上面 **style-loader 必须要写在 css-loader前面 ** 是因为webpack 读取使用loader 的过程中，是按照从右往左的顺序读取的。 less-loader其实和上面一个的都是安装 和 配置 先创建一个less 文件 依然放到 css文件夹 继续在官网中找到less-loader的相关使用说明 安装 less-loader （注意 还需要安装less 因为webpack需要使用less对less文件进行编译） 1npm install --save-dev less-loader less 修改对应的配置文件 添加一个rules 选项，用于处理 .less 文件 12345678910{ test: /\\.less$/,use: [{ loader: &quot;style-loader&quot; // creates style nodes from JS strings }, { loader: &quot;css-loader&quot; // translates CSS into CommonJS }, { loader: &quot;less-loader&quot; // compiles Less to CSS }]} 图片文件处理 图片资源处理分两种 小于 8kb 的分为一类 大于 8kb 的分为一类 使用两个loader url-loader 用于处理 小于8kb的文件 file-loader 用于处理 大于8kb的文件 其中 8kb 的标准可以从配置中修改，但是一般不改 url-loader 安装 1npm install --save-dev url--loader 配置 1234567891011{ test: /\\.(png|jpg|gif)$/, use: [ { loader: 'url-loader', options: { limit: 8192 // 这里就是 设置 8kb限制的地方 } } ] } 这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码 大于 8kb 的使用 file-loader 安装 1npm install --save-dev file-loader 配置 1234567891011121314{ test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', // options: { limit: 8192, name:'img/[name].[hash:8].[ext]' //在option中添加的选项设置新生成的图片存放位置和指定文件名 } } ] } 我们发现webpack自动帮我们生成了一个非常的名字 这一个32位hash值，目的是防止名字重复 但是真实开发中，我们可以能对打包的图片名字有一定的要求 比如，将所有的图片放到一个文件夹中，跟上图片原来的名称，同时也要防止重复、 所以我们可以在options中添加选项： img：文件要打包到的文件夹 name：获取图片原来的名字，放在该位置 hash8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位 ext，使用图片原来的拓展名 但是，我们发现图并没有显示出来，这事因为图片使用的路径不正确 默认情况下，webpack会将生成的路径直接返回给使用者 但是我们整个程序是打包在dist 文件夹下的，所以这里需要路径下再添加一个dist 123456// 出口，通常是一个对象，里面至少包含两个重要属性，path 和 filename output:{ path: path.resolve(__dirname,'dist'),// 注意 path通常是一个绝对路径 filename: 'bundle.js', public: 'dist/' } ES6语法处理如果需要将ES6语法 转成ES5 一样需要使用 loader 安装 1npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 配置 12345678910{ test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } webpack中配置Vue1. 安装 npm 安装 1npm install vue --save ## 可以指定版本 不需要加 dev 因为运行时也需要 2. 配置Vue在开发是发布了两个版本 runtime-only -&gt; 代码中不可以有任何template runtime-compiler -》 代码中可以有template 因为有compiler 可以用于 编译template 修改webpack配置 12345resolve:{ alias:{ 'vue$':'vue/dist/vue.esm.js' }} ！ 遇到报错 vue-loader有很多版本 从14.之后就需要自己配置一个插件 可以手动改一下版本 改回到13.0.0以上的版本 用 ^13.0.0 plugin的使用plugin是什么 plugin是插件的意思，通常是用于对某个现有的架构进行扩展 webpack中的插件，就是对webpack现有的功能的各种扩展，比如打包优化，文件压缩等等。 loader和plugin的区别 loader主要用于转换某些类型的模块，它本身是一个转换器。 plugin是插件，它是对webpack本身的扩展，是一个扩展。 plugin是使用方法： 步骤一： 通过npm安装需要使用 的plugin(某些webpack以及内置的插件不需要安装) 步骤二： 在webpack.config.js中的plugins中配置插件 添加版权的plugin用来给打包的文件添加版权声明 该插件名字叫做 BannerPlugin,属于webpack自带的插件 在webpakc.config.js文件配置 123456789const webpack require('webpack')moudule.exports = { ... plugins:[ new webpack.BannerPligin('这里写版权信息') new webpack.BannerPligin('最终版权归谁所有') ]} 打包HTML的 plugin目前，我们的index.html文件是存放在项目的根目录下的。 我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.js文件，那么打包的js等 文件也就没有意义了 所以我们需要将 index.html文件打包到 dist文件夹中，这个时候就可以使用 HtmlWebpackPulgin插件 HtmlWebpackPulgin插件可以为我们做这些事情 自动生成一个index.html文件 可以指定模板生成 将打包的js文件，自动通过 script标签插入到body 中 安装 HtmlWebpackPulgin 插件 1npm install html-webpack-plugin --save-dev 使用插件，修改webpack.config.js 文件 plugins 12345678plugins:{ new htmlWebpackPlugin({ template: 'index.html', // 这里的template 表示要根据什么模板来生成index.html // 另外，我们需要删除之前在output中添加的publiuc 属性 // 否则插入的script标签中的src可能会有问题 })} JS压缩的Plugin在项目发布之前，我们必然需要对js等文件进行压缩处理 这里，我们就对打包文件进行压缩 我们使用一个第三方插件 uglifyjs-webpack-pubgin ,并且版本号指定 1.1 .1，和CLI2保持一致 1npm install uglifly-webpack-plugin@1.1.1 --save-dev 修改webpack.config.js 文件，使用插件： 1234567891011const path = require('path')const webpack = require('webpack')const uglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = { ... plugins:[ new webpack.BannerPlugin = ('最终版权归AA所有') new uglifyJSPlugin() ]} 搭建本地服务器webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js，内部使用express框架，可以实现我们让浏览器自动刷新显示我们修改的效果。 不过它是一个单独的模块，在webpack中使用之前需要安装它 1npm install --save-dev webpack-dev-server@2.9.1 devserver也是作为webpack中的一个选项，选项本身可以设置如下属性： contentBase: 为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填 './dist' port : 端口号 inline : 页面实时刷新 (true/flase) historyApiFallback : 在SPA 页面中 依赖 HTML5 的 history 模式 webpack.config.json配置如下 1234devServer:{ contenBase: './dist', inline: true,} 我们还可以在package.json 配置一个 scripts 1&quot;dev&quot; : &quot;webpack-dev-server --open&quot; // --open表示直接打开浏览器 关于抽离配置的补充打包设置的抽离 因为开发与运行时配置不同 有的配置开发用 有的配置上线采用 所有需要将其抽离分开","link":"/2021/01/07/webpack/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"}]}