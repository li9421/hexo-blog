{"pages":[],"posts":[{"title":"AJAX","text":"HTTPHTTP (hypertext tranport protocol) 协议 【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则。 是约定，是规则 请求报文重点是格式和参数 12345678行 POST /s?ie=utf-8 HTTP/1.1头 HOST: atguigu.com Cookir: name=guigui Content-type: application/x-ww-from-urlencoded User-Agent: chrome 83 空行体 username=admin&amp;password=admin 响应报文123456789101112行 HTTP/1.1 200 OK头 Content-type： text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 响应代码http响应中常见的几种响应代码 200响应代码 Status Code: 200表示响应成功，很常见 300响应代码 Status Code: 301 表示客户端跳转(重定向）,永久性跳转，一般在servlet 中使用如下代码 12response.setStatus(301);response.setHeader(&quot;Location&quot;,&quot;fail.html&quot;) 302响应代码 Status Code : 302 客户端跳转，临时跳转，比如 访问页面 a.html,提交数据后就会跳转到 b.html 1response.sendRedirect(&quot;/a&quot;); 304 响应代码 Status Code : 304 表示资源未被修改，当不是第一次访问一个静态页面或者图片的时候，就会得到这么一个提示，这是服务端提示浏览器，这个资源没有发生改变，你直接使用上一次下载的就行了，不需要重新下载。这样就节约了带宽，并且浏览器的加载速度也会更快。 404 响应代码 Status Code ：404 表示访问的页面不存在，表示一个浏览器的错误，就是服务端没有提供这个服务，但是你却去访问。一般检查路径问题 500 响应代码 Status Code : 500 表示服务端错误，一般检查servlet。 其他相关代码 100 表示继续 401 表示未授权 402 表示需要付费(很少见) 403 表示禁止 405 表示方法不被允许 406 表示无法请求 (很少见) 408 表示请求超时 413 表示实体过大 (不知道什么意思不用深究) 507 表示存储不足 Ajax1. 原生AJAX1.1 AJAX 简介​ AJAX 全称为 Asynchronous JavaScript And XML 就是异步的JS 和 XML 。 ​ 通过 AJAX 可以在浏览器向服务器发送异步请求，最大的优势： 无刷新获取数据。 ​ AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 1.2 XML 简介​ XML 可拓展标记语言。 ​ XML 被设计用来传输和存储数据。 ​ XML 和 HTML 相似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。 1234567891011比如说我有一个学生：name:&quot;孙悟空&quot;;age =18; gender=&quot;男&quot;用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;但是现在已经被 JSON 取代了用JSON 表示：{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 18,&quot;gender&quot;=&quot;男&quot;} 1.3 AJAX 的特点1.3.1 AJAX的优点 1. 可以无需刷新页面而与服务器进行通信。 2. 允许你根据用户事件来更新部分页面内容 1.3.2 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 1.4 AJAX 的使用1.4.1 核心对象​ XMLHttpRequest: AJAX 是所有操作都是通过该对象进行的。 1.4.2 使用步骤123456789101112131415161718// 1. 创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求信息xhr.open(method.url); // method是求方法 ，get/post 当然还有别的// 可以设置请求头，一般不设置xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');// 3. 发送请求xhr.send(body) // get 请求 不传body 参数 ， 只有 post 请求使用// 4. 接受响应// xhr.responseXML 接受 xml 格式的响应数据// xhr.responseText 接受 文本格式的响应数据xhr.onreadustatechange = function() { if(xhr.readuState == 4 &amp;&amp; sht.status == 200) { var text = xhr.responseText; console.log(text); }} 1.4.3 解决id缓存问题​ 问题： 在一些浏览器(IE) ,由于缓存机制的存在，ajax 只会发生的第一次请求，剩余多次请求不会再发送给浏览器，而是直接加载缓存中的数据。 ​ 解决方式： 浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题 12345678910111213function(){ const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/ie?t=' + Date.now()); // 在url 后面加上参数为当前时间轴，就可以保证每次发送请求的链接都不一样 xhr.send(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { result.innerHTML = xhr.response; } } }} 1.4.4 AJAX 请求状态​ xhr.readyState 可以用来查看请求当前的状态 0 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有调用。 1 表示 send() 方法还没有调用，仍然可以使用 setRequestHeader(),设定 HTTP请求头信息 2 表示send() 方法已经执行，并且头信息和状态码已经收到。 3 表示正在 接受服务器传来的 body 部分数据。 4 表示服务器数据已经完全接收，或者本次接收已经失败 2. jQuery 中的 AJAX2.1 get 请求123456789101112$get(url,[data],[callback],[type])url: 请求的 URL 地址data: 请求携带的参数。callback: 载入成功时的回调函数。type： 设置返回内容的格式， xml。html,script.json text,_default实例 $.get('http://127.0.0.1:8000/jquery-server', { a: 100, b: 200}, function(data) { console.log(data); }, 'json') 2.2 post 请求123456789101112$.post(url, [data], [callback], [type])url:请求的 URL 地址。data:请求携带的参数。callback:载入成功时回调函数。type:设置返回内容格式，xml, html, script, json, text, _default。实例 $.post('http://127.0.0.1:8000/jquery-server', { a: 100,b: 200}, function(data) { console.log(data);}) 2.3 通过方法12345678910111213141516171819202122232425262728 $.ajax({ // url url: 'http://127.0.0.1:8000/jquery-server', // 发送参数 data: { a: 100, b: 200 }, // 请求的类型 type: 'GET', // 响应体结果 dataType: 'json', // 成功的回调 success: function(data) { console.log(data); }, // 失败的回调 error: function() { console.log('出错啦'); }, // 超时时间 timeout: 2000, // 头信息 headers: { c: 300, d: 400, }}) 3. 跨域3.1 同源策略​ 同源策略（Same-Origin Policy）最早是由 Netscape 网景公司提出的,浏览器的一种安全策略。 ​ 同源： 协议、域名、端口号 必须完全相同 ​ 违背同源策略就是跨域。 3.2 如何解决跨域3.2.1 JSONP JSONP是什么 JSONP(JSON with Padding),是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来的，只支持get 请求。 JSONP怎么工作 在网页中有一些标签天生具有跨域能力，比如 img link iframe script. JSONP 就是利用 script 标签 的跨域能力 来发送请求。 JSONP 的使用 动态创建一个 script 标签 var script = doucument.createElement(“script”); 设置 script 的 src ，设置回调函数 script.src = “http://loaclhost:3000/testAjAx?callback=abc&quot;; function abc(data) { ​ alert(data.name); }; 将 script 添加到 body 中 document.body.appendChild(script); 服务器中的路由处理 router.get(“/testAJAX”,function(req,res) { console.log(‘收到请求’) var callback = req.query.callback; var obj = { name:”孙悟空”， age:18 } res.send(callback+”(“+JSON.stringify(obj)+”)”); }) jQuery 中的 JSONP 1234$.getJSON('http://127.0.0.1:8000/jquery-jsonp-server?callback=?',function(data) { $('#xxx').html{ `名称： ${data.name},&lt;/br&gt; 校区： ${data.city}`)}) 3.2.2 CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS [MDN的CORS] CORS 是什么 CORS(Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何操作，完全在服务器中进行处理，支持get 和 post 请求，跨域资源共享标准新增了一组 HTTP 首部字段， 允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 是怎么工作的？ cors 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行 CORS 的使用 主要是 服务器端的设置： 123456router.get(&quot;/testAJAX&quot;,function(req,res){//通过 res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);res.send(&quot;testAJAX 返回的响应&quot;);})","link":"/hexo-blog/2021/01/01/AJAX/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hexo-blog/2021/01/02/hello-world/"},{"title":"","text":"详情页实现思路 一.点击商品进入详情页 GoodsListItem点击 点击之后获取商品的 iid 跳转到详情页，并且传入iid 二. 解决 - 首页 保持位置状态 ```deactivated: 记录离开时的位置 123+ ``` activated: 通过scrollTo 函数 设置离开时位置 bug： Better-Scroll 最新的1.15.0 有scrollT o 的位置 解决方法 ： 进行版本的回退 三. 详情页的导航栏实现 返回按钮 ： solt=&quot;left&quot; 标题列表 ： solt=&quot;center&quot; 四. 请求详情的数据 接口 /detail?iid 五. 轮播图的实现 Swiper/SwiperItem 六. 商品基本信息的展示 数据来自四面八方 对数据进行汇总：一个对象中 一个对象传入子组件 七. 店铺信息展示八. 商品图片的展示九. 参数信息的展示十. 评论信息的展示 时间格式化 服务器返回的时间戳 转成 date -》格式 yyyy-MM-dd hh:mm:ss 十一. 推荐数据的展示 请求推荐数据 GoodsList 展示数据 十二 , mixin 的使用 创建一个混入对象 const mixin = {} 组件对象中 ： mixins: [mixin] 十三.处理2个 bug 首页tabControl 详情滚动的bug 十四. 标题内容的联动效果14.1 点击标题滚动到对应的标题 在detail中监听标题的点击，获取index 滚动到对应的主题： 获取所有主题的offsetTop 问题：在哪里才能获取到正确的offsetTop created 肯定不行，压根不能获取数据 mounted 也不行，数据还没有获取到 获取数据的回调也不行，DOM还没有渲染完 $nextTick 也不行，因为图片的高度没有计算在内 在图片加载完成后，获取的高度才是正确的 14.2 内容滚动，显示正确的标题普通做法： 12345678(this.curentIndex !==i)&amp;&amp;((i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i=1]) || (i=== length -1 &amp;&amp; positionY &gt;= this.themeTopYs[i]))条件成立： this.currentIndex = i条件一： 防止赋值过于频繁条件二：((i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i=1]))条件1. i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] 判断区间： 在 0 和某个数字之间 （i&lt;length - 1）条件2： i=== length -1 &amp;&amp; positionY &gt;= this.themeTopYs[i]判断大于等于： i=== length - 1 hack做法 123this.currentIndex !== i &amp;&amp; (positionY &gt;= this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i+1])// 在数组后面加多一个 决定不会到达的值，比如 js 的最大值，或者 最后一个的几倍数// 这也就可以直接判断区间，不需要考虑最后一个 十五. 底部工具栏封装 detail-bottom-bar 十六. 详情页的回到顶部 home和detail 都有回到顶部 使用混入 mixin 十七. 点击加入购物车17.1 获取加入购物车的点击事件，并且获取商品的信息 监听 获取商品信息： iid/price/image/title… 17.2 将商品添加到vuex中 安装vuex 配置vuex 定义mutation， 将商品添加到statr.cartlist 重构代码 将mutation 抽到 actions （定义两个 mutation） 将 mutation/ actions 单独抽出到文件中 十八. 购物车的展示18.1 购物车的导航栏的展示18.2 购物车商品的展示 CartList -》 scroll（滚动问题） CartListItem -》 CheckButton 18.3 商品选中与不选中的切换 修改数据模型，改变选中与不选择 逻辑是： 修改数据模型的数据 数据发生改变 影响到视图，视图发生改变 18.4 底部工具栏的汇总 全选按钮 计算总价格 去计算按钮 十九. 购物车的全选按钮的逻辑 显示的状态 判断是否有一个不选中，就是不选中 点击全选按钮 如果原来都是选中的，点击一次，全部不选择 如果原来是不选中的或者有一个不选择，点击全部选中 二十. 添加购物车弹窗20.1 Vuex 的补充 Actions 可以返回一个Promise mapActions 映射关系 20.2 toast（吐司）封装 普通封装 插件封装 二十一. 补充一些细节21.1 fastclick 减小移动端点击的延迟 安装 fastclick 导入 调用attach 21.2 图片的懒加载 什么图片懒加载 图片需要显示到屏幕上再加载 使用 vue-lazyload 导入 Vue.use 修改 img :src 改成 v-lazy 22.3 px2vw 插件使用 安装插件 在 postcss.config.js中进行配置 面试题 如何理解Vue 的生命周期 如何进行非父子组件通信 Vue的响应式原理(初级的前端开发) 不要认为数据发生改变，界面跟着更新，并不是理所当然的 难点： 1.代码如何组织 2.业务逻辑(不要立即写代码 ，先组织逻辑)","link":"/hexo-blog/2021/01/02/%E8%AF%A6%E6%83%85%E9%A1%B5%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/hexo-blog/tags/AJAX/"}],"categories":[{"name":"前端","slug":"前端","link":"/hexo-blog/categories/%E5%89%8D%E7%AB%AF/"}]}