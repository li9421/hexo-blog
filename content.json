{"pages":[],"posts":[{"title":"AJAX","text":"HTTPHTTP (hypertext tranport protocol) 协议 【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则。 是约定，是规则 请求报文重点是格式和参数 12345678行 POST /s?ie=utf-8 HTTP/1.1头 HOST: atguigu.com Cookir: name=guigui Content-type: application/x-ww-from-urlencoded User-Agent: chrome 83 空行体 username=admin&amp;password=admin 响应报文123456789101112行 HTTP/1.1 200 OK头 Content-type： text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 响应代码http响应中常见的几种响应代码 200响应代码 Status Code: 200表示响应成功，很常见 300响应代码 Status Code: 301 表示客户端跳转(重定向）,永久性跳转，一般在servlet 中使用如下代码 12response.setStatus(301);response.setHeader(&quot;Location&quot;,&quot;fail.html&quot;) 302响应代码 Status Code : 302 客户端跳转，临时跳转，比如 访问页面 a.html,提交数据后就会跳转到 b.html 1response.sendRedirect(&quot;/a&quot;); 304 响应代码 Status Code : 304 表示资源未被修改，当不是第一次访问一个静态页面或者图片的时候，就会得到这么一个提示，这是服务端提示浏览器，这个资源没有发生改变，你直接使用上一次下载的就行了，不需要重新下载。这样就节约了带宽，并且浏览器的加载速度也会更快。 404 响应代码 Status Code ：404 表示访问的页面不存在，表示一个浏览器的错误，就是服务端没有提供这个服务，但是你却去访问。一般检查路径问题 500 响应代码 Status Code : 500 表示服务端错误，一般检查servlet。 其他相关代码 100 表示继续 401 表示未授权 402 表示需要付费(很少见) 403 表示禁止 405 表示方法不被允许 406 表示无法请求 (很少见) 408 表示请求超时 413 表示实体过大 (不知道什么意思不用深究) 507 表示存储不足 Ajax1. 原生AJAX1.1 AJAX 简介​ AJAX 全称为 Asynchronous JavaScript And XML 就是异步的JS 和 XML 。 ​ 通过 AJAX 可以在浏览器向服务器发送异步请求，最大的优势： 无刷新获取数据。 ​ AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 1.2 XML 简介​ XML 可拓展标记语言。 ​ XML 被设计用来传输和存储数据。 ​ XML 和 HTML 相似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。 1234567891011比如说我有一个学生：name:&quot;孙悟空&quot;;age =18; gender=&quot;男&quot;用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;但是现在已经被 JSON 取代了用JSON 表示：{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 18,&quot;gender&quot;=&quot;男&quot;} 1.3 AJAX 的特点1.3.1 AJAX的优点 1. 可以无需刷新页面而与服务器进行通信。 2. 允许你根据用户事件来更新部分页面内容 1.3.2 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 1.4 AJAX 的使用1.4.1 核心对象​ XMLHttpRequest: AJAX 是所有操作都是通过该对象进行的。 1.4.2 使用步骤123456789101112131415161718// 1. 创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求信息xhr.open(method.url); // method是求方法 ，get/post 当然还有别的// 可以设置请求头，一般不设置xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');// 3. 发送请求xhr.send(body) // get 请求 不传body 参数 ， 只有 post 请求使用// 4. 接受响应// xhr.responseXML 接受 xml 格式的响应数据// xhr.responseText 接受 文本格式的响应数据xhr.onreadustatechange = function() { if(xhr.readuState == 4 &amp;&amp; sht.status == 200) { var text = xhr.responseText; console.log(text); }} 1.4.3 解决id缓存问题​ 问题： 在一些浏览器(IE) ,由于缓存机制的存在，ajax 只会发生的第一次请求，剩余多次请求不会再发送给浏览器，而是直接加载缓存中的数据。 ​ 解决方式： 浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题 12345678910111213function(){ const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/ie?t=' + Date.now()); // 在url 后面加上参数为当前时间轴，就可以保证每次发送请求的链接都不一样 xhr.send(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { result.innerHTML = xhr.response; } } }} 1.4.4 AJAX 请求状态​ xhr.readyState 可以用来查看请求当前的状态 0 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有调用。 1 表示 send() 方法还没有调用，仍然可以使用 setRequestHeader(),设定 HTTP请求头信息 2 表示send() 方法已经执行，并且头信息和状态码已经收到。 3 表示正在 接受服务器传来的 body 部分数据。 4 表示服务器数据已经完全接收，或者本次接收已经失败 2. jQuery 中的 AJAX2.1 get 请求123456789101112$get(url,[data],[callback],[type])url: 请求的 URL 地址data: 请求携带的参数。callback: 载入成功时的回调函数。type： 设置返回内容的格式， xml。html,script.json text,_default实例 $.get('http://127.0.0.1:8000/jquery-server', { a: 100, b: 200}, function(data) { console.log(data); }, 'json') 2.2 post 请求123456789101112$.post(url, [data], [callback], [type])url:请求的 URL 地址。data:请求携带的参数。callback:载入成功时回调函数。type:设置返回内容格式，xml, html, script, json, text, _default。实例 $.post('http://127.0.0.1:8000/jquery-server', { a: 100,b: 200}, function(data) { console.log(data);}) 2.3 通过方法12345678910111213141516171819202122232425262728 $.ajax({ // url url: 'http://127.0.0.1:8000/jquery-server', // 发送参数 data: { a: 100, b: 200 }, // 请求的类型 type: 'GET', // 响应体结果 dataType: 'json', // 成功的回调 success: function(data) { console.log(data); }, // 失败的回调 error: function() { console.log('出错啦'); }, // 超时时间 timeout: 2000, // 头信息 headers: { c: 300, d: 400, }}) 3. 跨域3.1 同源策略​ 同源策略（Same-Origin Policy）最早是由 Netscape 网景公司提出的,浏览器的一种安全策略。 ​ 同源： 协议、域名、端口号 必须完全相同 ​ 违背同源策略就是跨域。 3.2 如何解决跨域3.2.1 JSONP JSONP是什么 JSONP(JSON with Padding),是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来的，只支持get 请求。 JSONP怎么工作 在网页中有一些标签天生具有跨域能力，比如 img link iframe script. JSONP 就是利用 script 标签 的跨域能力 来发送请求。 JSONP 的使用 动态创建一个 script 标签 var script = doucument.createElement(“script”); 设置 script 的 src ，设置回调函数 script.src = “http://loaclhost:3000/testAjAx?callback=abc&quot;; function abc(data) { ​ alert(data.name); }; 将 script 添加到 body 中 document.body.appendChild(script); 服务器中的路由处理 router.get(“/testAJAX”,function(req,res) { console.log(‘收到请求’) var callback = req.query.callback; var obj = { name:”孙悟空”， age:18 } res.send(callback+”(“+JSON.stringify(obj)+”)”); }) jQuery 中的 JSONP 1234$.getJSON('http://127.0.0.1:8000/jquery-jsonp-server?callback=?',function(data) { $('#xxx').html{ `名称： ${data.name},&lt;/br&gt; 校区： ${data.city}`)}) 3.2.2 CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS [MDN的CORS] CORS 是什么 CORS(Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何操作，完全在服务器中进行处理，支持get 和 post 请求，跨域资源共享标准新增了一组 HTTP 首部字段， 允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 是怎么工作的？ cors 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行 CORS 的使用 主要是 服务器端的设置： 123456router.get(&quot;/testAJAX&quot;,function(req,res){//通过 res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);res.send(&quot;testAJAX 返回的响应&quot;);})","link":"/2021/01/01/AJAX/"},{"title":"为什么会有这个网站","text":"或者说，这个网站是怎么来的，主要记录这个网站的搭建过程，记录一下步骤，防止以后忘了。 其实下面的东西全部都可以在官网查到，不知道为什么还要重复写，闲的的吧 这玩意挺麻烦的，主要意义还是在于折腾，如果只是单纯的想存笔记的话，隔壁有道云方便快捷 使用 HEXO + GithubPages 搭建静态网站1. hexo 介绍1.1 是什么Hexo 是一个基于 Node.js 开发的静态网页生成器，官方说明是博客框架，但是不仅仅可以用于博客，还可用于企业宣传站，产品展示，文本文档等信息展示为主的网站。 1.2 特点 超快速度 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkDown Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至还可以整合Octopress 的大多插件。 一键部署 只需一条指令即可部署到 GitHub Pages，Heroku 或其他平台。 丰富的主题 众多美观，强大的，可定制的主题中，选择；使用任何兼容的模板引擎创建自己的主题 丰富的插件支持 强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具 （Babel,PostCSS LESS/Sass） 轻易集成 2. 起步2.1 安装HexoHexo 依赖 Node.js 和 Git ，所以在安装 Hexo 之前必须确保安装了这两个工具。 2.1.1 安装Node.js就不赘述了，这忘了就是失忆了，去医院吧 2.1.2 安装 Git同上， 留给网址 git 下载 2.1.3 安装Hexo123npm install -g hexo-cli # -g 全局安装hexo --version # 确认版本 2.2 使用 Hexo 生成本地网站在命令行中执行下面的命令来创建网站。 1234hexo init 网站目录名称#例如hexo init my-blog 创建成功的话会生成一个具有下面目录结构的网站项目。 12345678.├── _config.yml 网站配置文件├── package.json 包说明文件├── scaffolds 文章模板目录├── source 源码目录| ├── _drafts 草稿文章目录| └── _posts 发布文章目录└── themes 主题目录 2.3 预览本地网站1npm run server # 这个自己懂的 也可以改 2.4 写文章 创建文章 方式一： 手动创建 方式二：使用命令 hexo new 文章文件名称 写文章 文章配置 语法： YAML Front-matter 文章配置 很重要 开头记得写 可配置项 （https://hexo.io/zh-cn/docs/front-matter） 文章正文 语法： Markdown 编辑工具：推荐Typora 超好用的 2.5 发布 自己搭建服务器 使用第三方云服务 使用第三方网站托管 3. Github PagesGitHub Pages 是 GitHub 提供的一个免费的静态网页托管服务(需要公开仓库才可以，私人仓库使用需要付费，码云好点，但是码云的自动部署需要付费，所以只能选择GitHub) 3.1 注册 GitHub 账户3.2 创建仓库3.3 提交文件3.4 将仓库托管到 GitHub Pages3.5 关于域名3.5.1 GitHub 提供的默认域名 用户名.github.io 用户名.github.io/仓库名称 3.5.2 自定义域名 去买一个域名 在你的域名后台配置 CNAME 到 GitHub 在 GitHub 仓库中添加 CNAME 文件 其中要写入你的自定义域名网址 4 将本地网站部署到 GitHub Pages正确的方式是： 编译构建 将构建结果推送到 GitHub 仓库 开启 GitHub Pages 每次更新都需要重复上面的流程，太过繁琐，不推荐 4.1 GitHub ： 创建仓库4.2 GitHub ： 生成Github 访问 token GitHub 头像下方找到 Settings 找到 Developer Settings 找到 Personal access tokens 点击 Generate new token (文字可能会变，但大概就是这个意思的) 然后给 token 起一个名字，可以随便 但一定 英文 只是注释 然后 勾上 repo 的权限 然后 点击 下面的Generate token 按钮 然后页面就会 生成 一大串长码 注意 这个只会出现一次 记得复制保存好，没有就得重新生成又是不一样的一个 4.3 GitHub ： 将 token 配置到项目的secrets 中 然后打开项目仓库 点击 项目的 Setting 注意是 项目的 上面的是账户的 找到 Secrets 点击 旧版 是 Add a new secret 目前2021.1.3是 New repository secret 然后起一个 name, 虽然可以随便起 但是建议写，ACCESS_TOKEN 否则后面的代码也要改 然后把刚刚复制的长码 填到 Value 点击 Add secret 4.4 本地 : 配置网站根目录本地操作 在 _config.yml 中修改 配置 url 改为 网站的网址 root ： 网站的根路径 如果部署的网址是根路径 则写 / 如果部署的网址是子目录，则这里写 `/子目录/` 4.5 配置 GitHub ACtions在项目中创建，.github/workflows/main.yml并写入以下配置内容 1234567891011121314151617181920212223242526272829303132333435363738name: build and deploy# 当 master 分支 push 代码的时候 触发 workflowon: push: branches: - main # 注意这里是个坑 推送的分支要对 main 和 master容易搞死人jobs: build-deploy: runs-on: ubuntu-latest steps: # 下载仓库代码 - uses: actions/checkout@v2 # 缓存依赖 - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- # 安装依赖 - run: npm ci # 打包构建 - run: npm run build # 发布到 GitHub Pages - name: Deploy uses: peaceiris/actions-gh-pages@v2 env: PERSONAL_TOKEN: ${{ secrets.ACCESS_TOKEN }} # 这里的名字就是 刚刚起的secret，要一样 PUBLISH_BRANCH: gh-pagesPUBLISH_DIR: ./public 在配置 Actions 自动部署时， 总是执行到 Deploy 这一步就会报错，remote: Invalid username or password. fatal: Authentication failed for ‘https://github.com/li9421/hexo-blog.git/'` 就是用户名密码错误 ，无法链接到远程仓库，而该项目是通过 token 来访问仓库的，尝试更新项目的 token 可能可以解决问题，但是时好时坏的，目前推测一个 token 可能是由时效的 但还没有实锤. 目前记录 1.3 号下午 Sun Jan 3 07:00:56 UTC 配置一个 token 到 1.4晚上 23点 Mon Jan 4 15:23:16 UTC 目前还是正常，继续观察 , 1.7晚上 Thu Jan 7 15:28:08 UTC 2021 还是正常,两次都正常。 4.6 本地 ： 推送文件到远程仓库1234git init git add .git commit -m &quot;&quot;git push 提交之后要确认的事 查看代码是否提交到线上 查看 GitHub Actions 是否已经开始工作 查看 GitHub Actions 是否工作成功 查看部署之后的网站 4.7 之后怎么更新上面的一些列流程配置好之后，以后作者就只需要 安安静静的写你的博客 （也就是 markdowm）就好了，如果需要更新，只需要使用 git 提交推送项目的源码就可以了，push会自动触发 GitHub Actions 自动构建部署 5. 实践分享 不定期更 5.1 文章图片 本地 source/images 文章资源文件夹 这样方便，但要考虑路径问题啊，文件大小问题啊 在线图床(推荐使用) 新浪已经挂了 用七牛云就是麻烦 需要搞很多事 但是弄好就很方便了 只要把图片上传后 获得一个url 就可以在 markdown中就可以直接引用 5.2 草稿文章5.2.1 默认方式新建草稿文章： 1hexo new draft &lt;title&gt; 预览草稿 ： 1hexo server --draft 将草稿发布为正式文章 1hexo publish [layout] &lt;filename&gt; 5.2.2 hexo-hide-posts 插件5.2.3 折叠文章不希望首页就把文章全部显示 这样会把首页拉的老长 可以使用 1&lt;!-- more --&gt; &lt;!-- more --&gt; 会生成一个 阅读更多的按钮， 后面的内容就不会显示在首页了 5.3 网站主题（https://hexo.io/themes/）这次我们选择的主题是 icarus 中文文档(https://blog.zhangruipeng.me/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/) 5.4 自动部署加自定义域名的问题想要自定义域名 需要在 在根目录放一个 CNAME文件，但是 Actions 自动部署每次都会把文件覆盖掉， 导致域名不会解析。可是配置文件里的url又是自定义的，最终导致两条链接都打不开, 解决方法是 手动在 hexo 根目录下 的 source目录下保存一个 CNAME文件，这要 npm run build 后 public 目录下就会有一个 CNAME文件","link":"/2021/01/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99/"},{"title":"前端模块化","text":"为什么要有模块化 webpack认识webpack 什么是webpack 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具 主要两点 模块 打包 前端模块化 ： 前面已经提到过为什么需要模块化 而且也提到了目前前端模块化的一些方案： AMD 、CMD、CommonJS、ES6 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成项目后还需要处理模块间的各种依赖，并且将其进行整合打包。 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在 webpack中都可以被当作模块来使用(在后续我们会看到)。 这就是webpack中的模块化的概念 打包webpack的安装 必须先安装node webpack的起步webpack的配置1webpack ./src/main.js ./dist/bundle.js loader的使用swebpack中配置Vue1. 安装 npm 安装 1npm install vue --save ## 可以指定版本 不需要加 dev 因为运行时也需要 2. 配置Vue在开发是发布了两个版本 runtime-only -&gt; 代码中不可以有任何template runtime-compiler -》 代码中可以有template 因为有compiler 可以用于 编译template ！ 报错 vue-loader有很多版本 从14.之后就需要自己配置一个插件 可以手动改一下版本 改回到13.0.0以上的版本 用 ^13.0.0 plugin的使用插件 对现有的框架进行扩展 搭建本地服务器补充打包设置的抽离 因为开发与运行时配置不同 有的配置开发用 有的配置上线采用 所有需要将其抽离分开","link":"/2021/01/03/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"webpack","text":"认识webpackwebpack官网 (纯英文的可能看不懂) webpack中文网 什么是webpack 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具 主要两点 模块 打包 前端模块化 ： 前面已经提到过为什么需要模块化 而且也提到了目前前端模块化的一些方案： AMD 、CMD、CommonJS、ES6 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成项目后还需要处理模块间的各种依赖，并且将其进行整合打包。 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在 webpack中都可以被当作模块来使用(在后续我们会看到)。 这就是webpack中的模块化的概念 打包:打包如何理解呢？ 理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系的后，打包的概念就非常好理解了。 就是将webpack中的各种资源合并成一个或多个包（Bundle） 并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss/less等转成css，将ES6语法转成ES5语法，将typescrip转成JavaScript等等操作 但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢 webpack的安装 必须先安装Node.JS npm 全局安装 webpack 1npm install webpack@3.6.0 -g ## 这里指定3.6.0版本因为vue cli2依赖该版本 局部安装webpack --save-dev 指开发时依赖，项目打包后不需要继续使用的。 12cd 对应目录npm install webpack@3.6.0 --save-dev 为什么全局安装后还需要局部安装？ 在终端直接执行webpack命令，使用的全局安装的webpack 当在package.json中定义了scripts 时，其中包含webpack 命令，那么使用的是局部webpack 为避免全局与局部配置版本不同等，建议使用当前局部安装webpack打包当前的代码资源 webpack的起步准备工作： 创建如下文件和文件夹 文件和文件夹解析： dist 文件夹： 用于存放打包后的文件 src 文件夹： 用于存放我们写的源文件 main.js : 项目的入口文件。具体内容查看详情 index.html : 浏览器打开展示的首页html package.json ： 通过npm init 生成的，npm包管理的文件 JS文件的打包现在的js文件中使用了模块化的方式进行打包，但是不可以直接使用 因为如果直接在index.html引入这些js文件，浏览器并不能识别其中的模块化代码 另外，在真实的项目中会有很多这样的js文件，我们一个一个引用非常麻烦，并且后期非常不方便对他们进行管理。 应该使用 webpack 工具 对多个js文件进行打包 我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。(具体原理看后面) 另外，如果在处理完所有模块之间的关系后，将多个js文件打包到一个js文件中引入就方便很多了 webpack 打包指令 1webpack src/main.js dist/bundle.js 打包后会在dist 文件下 生成一个 bundle.js文件 文件很复杂 基本可以不看 bundle.js文件是webpack 处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可 webpack的配置1webpack ./src/main.js ./dist/bundle.js 入口和出口我们考虑到：如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一个中方法可以将这个两个函数参数写道配置中，在运行的时候直接读取 webpack配置方法 创建一个webpack.json文件 1234567891011const path - requre('path') // 引入node 默认模块moudule.exprots = { // 入口： 可以是字符串/数组/对象，这里文明入口只有一个，所有写一个字符串及可 entry: './src/main.js', // 出口，通常是一个对象，里面至少包含两个重要属性，path 和 filename output:{ path: path.resolve(__dirname,'dist'),// 注意 path通常是一个绝对路径 filename: 'bundle.js' }} 局部安装webpack目前，我们使用的webpack是全局的webpack，如果我们想局部打包 因为一个项目往往依赖特定的webpack版本，全局的版本可能和这个项目的webpack版本不一致，导致打包出现问题 通常一个项目都有自己局部的webpack。 第一步，项目中需要安装自己局部的webpack 这里我们让局部安装webpack3.6.0 Vue CLi3中已经升级到了webpack4 但是它将配置文件隐藏起来了，所以查起来不是很方便。 1npm install webpack@3.6.0 --save-dev 第二步，通过node_modules/.bin/webpack启动webpack打包package.json中定义启动由于上面启动方式太麻烦，我们可以在package.json的scripts中定义自己的执行脚本 package.json中的scripts脚本在实行时，会按照一定的顺序寻找命令对应的位置 首先，会先寻找本地的node_modules/.bin路径中对应的命令 如果没有找到，会去全局的环境变量中寻找 如果执行我们的build指令 1npm run build loader的使用什么是loaderloader是webpack中一个非常核心的概念 webpack用来做什么呢？ 在我们之前的实例中，我们主要用webpack 来处理我们写的js代码，并且 webpack 会自动处理js之间相关的依赖。 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css，图片，也包括一些高级的将ES6转成ES5代码，将Typescript转成JavaScript，将scss、less转成css，将.jsx、.vue文件转成js文件等等。 但是对于webpack本身来说，对于这些转化是不支持的。 那怎么办呢? 给webpack拓展对应的loader就可以啦 loader使用步骤： 步骤一： 通过npm 安装需要使用的loader 步骤二：在webpack.config.json中的modules 关键字下进行配置 大部分的loader我们都可以在webpack的官网中找到，并且学习对应的用法。 css文件处理准备工作项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中 在src目录中，创建一个css 文件，其中创建一个normal.css文件 我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。 在入口文件中引用 123// main.jsrequire('对应的位置/css/normal.css')// 然后重新打包 此时就会报错 告诉我们需要有对应的loader css-loader在webpack官网中， 可以找到关于样式的loader使用方法 1npm install --save-dev css-loader ## 安装 css-loader webpack.config.json 1234567891011module.exports = { module: { // 在rules 这个数组里配置 loader rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ] }} 按照官方配置的webpack.config.json,会发现有一个style-loader。 style-loader除了css-loader 我们还需要一个style-loader 1npm install --save-dev style-loader ## 安装 配置 webpack.config.json 1234567891011module.exports = { module: { // 在rules 这个数组里配置 loader rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] // css 和 style的位置固定 } ] }} 其中 css-loader 是用来解析 css 文件的 style-loader 是用来将样式添加到DOM中的 但是上面 **style-loader 必须要写在 css-loader前面 ** 是因为webpack 读取使用loader 的过程中，是按照从右往左的顺序读取的。 less-loader其实和上面一个的都是安装 和 配置 先创建一个less 文件 依然放到 css文件夹 继续在官网中找到less-loader的相关使用说明 安装 less-loader （注意 还需要安装less 因为webpack需要使用less对less文件进行编译） 1npm install --save-dev less-loader less 修改对应的配置文件 添加一个rules 选项，用于处理 .less 文件 12345678910{ test: /\\.less$/,use: [{ loader: &quot;style-loader&quot; // creates style nodes from JS strings }, { loader: &quot;css-loader&quot; // translates CSS into CommonJS }, { loader: &quot;less-loader&quot; // compiles Less to CSS }]} 图片文件处理 图片资源处理分两种 小于 8kb 的分为一类 大于 8kb 的分为一类 使用两个loader url-loader 用于处理 小于8kb的文件 file-loader 用于处理 大于8kb的文件 其中 8kb 的标准可以从配置中修改，但是一般不改 url-loader 安装 1npm install --save-dev url--loader 配置 1234567891011{ test: /\\.(png|jpg|gif)$/, use: [ { loader: 'url-loader', options: { limit: 8192 // 这里就是 设置 8kb限制的地方 } } ] } 这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码 大于 8kb 的使用 file-loader 安装 1npm install --save-dev file-loader 配置 1234567891011121314{ test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', // options: { limit: 8192, name:'img/[name].[hash:8].[ext]' //在option中添加的选项设置新生成的图片存放位置和指定文件名 } } ] } 我们发现webpack自动帮我们生成了一个非常的名字 这一个32位hash值，目的是防止名字重复 但是真实开发中，我们可以能对打包的图片名字有一定的要求 比如，将所有的图片放到一个文件夹中，跟上图片原来的名称，同时也要防止重复、 所以我们可以在options中添加选项： img：文件要打包到的文件夹 name：获取图片原来的名字，放在该位置 hash8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位 ext，使用图片原来的拓展名 但是，我们发现图并没有显示出来，这事因为图片使用的路径不正确 默认情况下，webpack会将生成的路径直接返回给使用者 但是我们整个程序是打包在dist 文件夹下的，所以这里需要路径下再添加一个dist 123456// 出口，通常是一个对象，里面至少包含两个重要属性，path 和 filename output:{ path: path.resolve(__dirname,'dist'),// 注意 path通常是一个绝对路径 filename: 'bundle.js', public: 'dist/' } ES6语法处理如果需要将ES6语法 转成ES5 一样需要使用 loader 安装 1npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 配置 12345678910{ test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } webpack中配置Vue1. 安装 npm 安装 1npm install vue --save ## 可以指定版本 不需要加 dev 因为运行时也需要 2. 配置Vue在开发是发布了两个版本 runtime-only -&gt; 代码中不可以有任何template runtime-compiler -》 代码中可以有template 因为有compiler 可以用于 编译template 修改webpack配置 12345resolve:{ alias:{ 'vue$':'vue/dist/vue.esm.js' }} ！ 遇到报错 vue-loader有很多版本 从14.之后就需要自己配置一个插件 可以手动改一下版本 改回到13.0.0以上的版本 用 ^13.0.0 plugin的使用plugin是什么 plugin是插件的意思，通常是用于对某个现有的架构进行扩展 webpack中的插件，就是对webpack现有的功能的各种扩展，比如打包优化，文件压缩等等。 loader和plugin的区别 loader主要用于转换某些类型的模块，它本身是一个转换器。 plugin是插件，它是对webpack本身的扩展，是一个扩展。 plugin是使用方法： 步骤一： 通过npm安装需要使用 的plugin(某些webpack以及内置的插件不需要安装) 步骤二： 在webpack.config.js中的plugins中配置插件 添加版权的plugin用来给打包的文件添加版权声明 该插件名字叫做 BannerPlugin,属于webpack自带的插件 在webpakc.config.js文件配置 123456789const webpack require('webpack')moudule.exports = { ... plugins:[ new webpack.BannerPligin('这里写版权信息') new webpack.BannerPligin('最终版权归谁所有') ]} 打包HTML的 plugin目前，我们的index.html文件是存放在项目的根目录下的。 我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.js文件，那么打包的js等 文件也就没有意义了 所以我们需要将 index.html文件打包到 dist文件夹中，这个时候就可以使用 HtmlWebpackPulgin插件 HtmlWebpackPulgin插件可以为我们做这些事情 自动生成一个index.html文件 可以指定模板生成 将打包的js文件，自动通过 script标签插入到body 中 安装 HtmlWebpackPulgin 插件 1npm install html-webpack-plugin --save-dev 使用插件，修改webpack.config.js 文件 plugins 12345678plugins:{ new htmlWebpackPlugin({ template: 'index.html', // 这里的template 表示要根据什么模板来生成index.html // 另外，我们需要删除之前在output中添加的publiuc 属性 // 否则插入的script标签中的src可能会有问题 })} JS压缩的Plugin在项目发布之前，我们必然需要对js等文件进行压缩处理 这里，我们就对打包文件进行压缩 我们使用一个第三方插件 uglifyjs-webpack-pubgin ,并且版本号指定 1.1 .1，和CLI2保持一致 1npm install uglifly-webpack-plugin@1.1.1 --save-dev 修改webpack.config.js 文件，使用插件： 1234567891011const path = require('path')const webpack = require('webpack')const uglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = { ... plugins:[ new webpack.BannerPlugin = ('最终版权归AA所有') new uglifyJSPlugin() ]} 搭建本地服务器webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js，内部使用express框架，可以实现我们让浏览器自动刷新显示我们修改的效果。 不过它是一个单独的模块，在webpack中使用之前需要安装它 1npm install --save-dev webpack-dev-server@2.9.1 devserver也是作为webpack中的一个选项，选项本身可以设置如下属性： contentBase: 为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填 './dist' port : 端口号 inline : 页面实时刷新 (true/flase) historyApiFallback : 在SPA 页面中 依赖 HTML5 的 history 模式 webpack.config.json配置如下 1234devServer:{ contenBase: './dist', inline: true,} 我们还可以在package.json 配置一个 scripts 1&quot;dev&quot; : &quot;webpack-dev-server --open&quot; // --open表示直接打开浏览器 关于抽离配置的补充打包设置的抽离 因为开发与运行时配置不同 有的配置开发用 有的配置上线采用 所有需要将其抽离分开","link":"/2021/01/07/webpack/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}