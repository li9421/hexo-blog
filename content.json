{"pages":[],"posts":[{"title":"AJAX","text":"HTTPHTTP (hypertext tranport protocol) 协议 【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则。 是约定，是规则 请求报文重点是格式和参数 12345678行 POST /s?ie=utf-8 HTTP/1.1头 HOST: atguigu.com Cookir: name=guigui Content-type: application/x-ww-from-urlencoded User-Agent: chrome 83 空行体 username=admin&amp;password=admin 响应报文123456789101112行 HTTP/1.1 200 OK头 Content-type： text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 响应代码http响应中常见的几种响应代码 200响应代码 Status Code: 200表示响应成功，很常见 300响应代码 Status Code: 301 表示客户端跳转(重定向）,永久性跳转，一般在servlet 中使用如下代码 12response.setStatus(301);response.setHeader(&quot;Location&quot;,&quot;fail.html&quot;) 302响应代码 Status Code : 302 客户端跳转，临时跳转，比如 访问页面 a.html,提交数据后就会跳转到 b.html 1response.sendRedirect(&quot;/a&quot;); 304 响应代码 Status Code : 304 表示资源未被修改，当不是第一次访问一个静态页面或者图片的时候，就会得到这么一个提示，这是服务端提示浏览器，这个资源没有发生改变，你直接使用上一次下载的就行了，不需要重新下载。这样就节约了带宽，并且浏览器的加载速度也会更快。 404 响应代码 Status Code ：404 表示访问的页面不存在，表示一个浏览器的错误，就是服务端没有提供这个服务，但是你却去访问。一般检查路径问题 500 响应代码 Status Code : 500 表示服务端错误，一般检查servlet。 其他相关代码 100 表示继续 401 表示未授权 402 表示需要付费(很少见) 403 表示禁止 405 表示方法不被允许 406 表示无法请求 (很少见) 408 表示请求超时 413 表示实体过大 (不知道什么意思不用深究) 507 表示存储不足 Ajax1. 原生AJAX1.1 AJAX 简介​ AJAX 全称为 Asynchronous JavaScript And XML 就是异步的JS 和 XML 。 ​ 通过 AJAX 可以在浏览器向服务器发送异步请求，最大的优势： 无刷新获取数据。 ​ AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 1.2 XML 简介​ XML 可拓展标记语言。 ​ XML 被设计用来传输和存储数据。 ​ XML 和 HTML 相似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。 1234567891011比如说我有一个学生：name:&quot;孙悟空&quot;;age =18; gender=&quot;男&quot;用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt;但是现在已经被 JSON 取代了用JSON 表示：{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 18,&quot;gender&quot;=&quot;男&quot;} 1.3 AJAX 的特点1.3.1 AJAX的优点 1. 可以无需刷新页面而与服务器进行通信。 2. 允许你根据用户事件来更新部分页面内容 1.3.2 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 1.4 AJAX 的使用1.4.1 核心对象​ XMLHttpRequest: AJAX 是所有操作都是通过该对象进行的。 1.4.2 使用步骤123456789101112131415161718// 1. 创建XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求信息xhr.open(method.url); // method是求方法 ，get/post 当然还有别的// 可以设置请求头，一般不设置xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');// 3. 发送请求xhr.send(body) // get 请求 不传body 参数 ， 只有 post 请求使用// 4. 接受响应// xhr.responseXML 接受 xml 格式的响应数据// xhr.responseText 接受 文本格式的响应数据xhr.onreadustatechange = function() { if(xhr.readuState == 4 &amp;&amp; sht.status == 200) { var text = xhr.responseText; console.log(text); }} 1.4.3 解决id缓存问题​ 问题： 在一些浏览器(IE) ,由于缓存机制的存在，ajax 只会发生的第一次请求，剩余多次请求不会再发送给浏览器，而是直接加载缓存中的数据。 ​ 解决方式： 浏览器的缓存是根据 url 地址来记录的，所以我们只需要修改 url 地址即可避免缓存问题 12345678910111213function(){ const xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1:8000/ie?t=' + Date.now()); // 在url 后面加上参数为当前时间轴，就可以保证每次发送请求的链接都不一样 xhr.send(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { result.innerHTML = xhr.response; } } }} 1.4.4 AJAX 请求状态​ xhr.readyState 可以用来查看请求当前的状态 0 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有调用。 1 表示 send() 方法还没有调用，仍然可以使用 setRequestHeader(),设定 HTTP请求头信息 2 表示send() 方法已经执行，并且头信息和状态码已经收到。 3 表示正在 接受服务器传来的 body 部分数据。 4 表示服务器数据已经完全接收，或者本次接收已经失败 2. jQuery 中的 AJAX2.1 get 请求123456789101112$get(url,[data],[callback],[type])url: 请求的 URL 地址data: 请求携带的参数。callback: 载入成功时的回调函数。type： 设置返回内容的格式， xml。html,script.json text,_default实例 $.get('http://127.0.0.1:8000/jquery-server', { a: 100, b: 200}, function(data) { console.log(data); }, 'json') 2.2 post 请求123456789101112$.post(url, [data], [callback], [type])url:请求的 URL 地址。data:请求携带的参数。callback:载入成功时回调函数。type:设置返回内容格式，xml, html, script, json, text, _default。实例 $.post('http://127.0.0.1:8000/jquery-server', { a: 100,b: 200}, function(data) { console.log(data);}) 2.3 通过方法12345678910111213141516171819202122232425262728 $.ajax({ // url url: 'http://127.0.0.1:8000/jquery-server', // 发送参数 data: { a: 100, b: 200 }, // 请求的类型 type: 'GET', // 响应体结果 dataType: 'json', // 成功的回调 success: function(data) { console.log(data); }, // 失败的回调 error: function() { console.log('出错啦'); }, // 超时时间 timeout: 2000, // 头信息 headers: { c: 300, d: 400, }}) 3. 跨域3.1 同源策略​ 同源策略（Same-Origin Policy）最早是由 Netscape 网景公司提出的,浏览器的一种安全策略。 ​ 同源： 协议、域名、端口号 必须完全相同 ​ 违背同源策略就是跨域。 3.2 如何解决跨域3.2.1 JSONP JSONP是什么 JSONP(JSON with Padding),是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来的，只支持get 请求。 JSONP怎么工作 在网页中有一些标签天生具有跨域能力，比如 img link iframe script. JSONP 就是利用 script 标签 的跨域能力 来发送请求。 JSONP 的使用 动态创建一个 script 标签 var script = doucument.createElement(“script”); 设置 script 的 src ，设置回调函数 script.src = “http://loaclhost:3000/testAjAx?callback=abc&quot;; function abc(data) { ​ alert(data.name); }; 将 script 添加到 body 中 document.body.appendChild(script); 服务器中的路由处理 router.get(“/testAJAX”,function(req,res) { console.log(‘收到请求’) var callback = req.query.callback; var obj = { name:”孙悟空”， age:18 } res.send(callback+”(“+JSON.stringify(obj)+”)”); }) jQuery 中的 JSONP 1234$.getJSON('http://127.0.0.1:8000/jquery-jsonp-server?callback=?',function(data) { $('#xxx').html{ `名称： ${data.name},&lt;/br&gt; 校区： ${data.city}`)}) 3.2.2 CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS [MDN的CORS] CORS 是什么 CORS(Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何操作，完全在服务器中进行处理，支持get 和 post 请求，跨域资源共享标准新增了一组 HTTP 首部字段， 允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 是怎么工作的？ cors 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行 CORS 的使用 主要是 服务器端的设置： 123456router.get(&quot;/testAJAX&quot;,function(req,res){//通过 res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);res.send(&quot;testAJAX 返回的响应&quot;);})","link":"/hexo-blog/2021/01/01/AJAX/"},{"title":"为什么会有这个网站","text":"或者说，这个网站是怎么来的，主要记录这个网站的搭建过程，记录一下步骤，防止以后忘了。 其实下面的东西全部都可以在官网查到，不知道为什么还要重复写，闲的的吧 使用 HEXO + GithubPages 搭建静态网站1. hexo 介绍1.1 是什么Hexo 是一个基于 Node.js 开发的静态网页生成器，官方说明是博客框架，但是不仅仅可以用于博客，还可用于企业宣传站，产品展示，文本文档等信息展示为主的网站。 1.2 特点 超快速度 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkDown Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至还可以整合Octopress 的大多插件。 一键部署 只需一条指令即可部署到 GitHub Pages，Heroku 或其他平台。 丰富的主题 众多美观，强大的，可定制的主题中，选择；使用任何兼容的模板引擎创建自己的主题 丰富的插件支持 强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具 （Babel,PostCSS LESS/Sass） 轻易集成 2. 起步2.1 安装HexoHexo 依赖 Node.js 和 Git ，所以在安装 Hexo 之前必须确保安装了这两个工具。 2.1.1 安装Node.js就不赘述了，这忘了就是失忆了，去医院吧 2.1.2 安装 Git同上， 留给网址 git 下载 2.1.3 安装Hexo123npm install -g hexo-cli # -g 全局安装hexo --version # 确认版本 2.2 使用 Hexo 生成本地网站在命令行中执行下面的命令来创建网站。 1234hexo init 网站目录名称#例如hexo init my-blog 创建成功的话会生成一个具有下面目录结构的网站项目。 12345678.├── _config.yml 网站配置文件├── package.json 包说明文件├── scaffolds 文章模板目录├── source 源码目录| ├── _drafts 草稿文章目录| └── _posts 发布文章目录└── themes 主题目录 2.3 预览本地网站1npm run server # 这个自己懂的 也可以改 2.4 写文章 创建文章 方式一： 手动创建 方式二：使用命令 hexo new 文章文件名称 写文章 文章配置 语法： YAML Front-matter 文章配置 很重要 开头记得写 可配置项 （https://hexo.io/zh-cn/docs/front-matter） 文章正文 语法： Markdown 编辑工具：推荐Typora 超好用的 2.5 发布 自己搭建服务器 使用第三方云服务 使用第三方网站托管 3. Github PagesGitHub Pages 是 GitHub 提供的一个免费的静态网页托管服务(需要公开仓库才可以，私人仓库使用需要付费，码云好点，但是码云的自动部署需要付费，所以只能选择GitHub) 3.1 注册 GitHub 账户3.2 创建仓库3.3 提交文件3.4 将仓库托管到 GitHub Pages3.5 关于域名3.5.1 GitHub 提供的默认域名 用户名.github.io 用户名.github.io/仓库名称 3.5.2 自定义域名 去买一个域名 在你的域名后台配置 CNAME 到 GitHub 在 GitHub 仓库中添加 CNAME 文件 其中要写入你的自定义域名网址 4 将本地网站部署到 GitHub Pages正确的方式是： 编译构建 将构建结果推送到 GitHub 仓库 开启 GitHub Pages 每次更新都需要重复上面的流程，太过繁琐，不推荐 4.1 GitHub ： 创建仓库4.2 GitHub ： 生成Github 访问 token GitHub 头像下方找到 Settings 找到 Developer Settings 找到 Personal access tokens 点击 Generate new token (文字可能会变，但大概就是这个意思的) 然后给 token 起一个名字，可以随便 但一定 英文 只是注释 然后 勾上 repo 的权限 然后 点击 下面的Generate token 按钮 然后页面就会 生成 一大串长码 注意 这个只会出现一次 记得复制保存好，没有就得重新生成又是不一样的一个 4.3 GitHub ： 将 token 配置到项目的secrets 中 然后打开项目仓库 点击 项目的 Setting 注意是 项目的 上面的是账户的 找到 Secrets 点击 旧版 是 Add a new secret 目前2021.1.3是 New repository secret 然后起一个 name, 虽然可以随便起 但是建议写，ACCESS_TOKEN 否则后面的代码也要改 然后把刚刚复制的长码 填到 Value 点击 Add secret 4.4 本地 : 配置网站根目录本地操作 在 _config.yml 中修改 配置 url 改为 网站的网址 root ： 网站的根路径 如果部署的网址是根路径 则写 / 如果部署的网址是子目录，则这里写 `/子目录/` 4.5 配置 GitHub ACtions在项目中创建，.github/workflows/main.yml并写入以下配置内容 1234567891011121314151617181920212223242526272829303132333435363738name: build and deploy# 当 master 分支 push 代码的时候 触发 workflowon: push: branches: - main # 注意这里是个坑 推送的分支要对 main 和 master容易搞死人jobs: build-deploy: runs-on: ubuntu-latest steps: # 下载仓库代码 - uses: actions/checkout@v2 # 缓存依赖 - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- # 安装依赖 - run: npm ci # 打包构建 - run: npm run build # 发布到 GitHub Pages - name: Deploy uses: peaceiris/actions-gh-pages@v2 env: PERSONAL_TOKEN: ${{ secrets.ACCESS_TOKEN }} # 这里的名字就是 刚刚起的secret，要一样 PUBLISH_BRANCH: gh-pages PUBLISH_DIR: ./public 4.6 本地 ： 推送文件到远程仓库1234git init git add .git commit -m &quot;&quot;git push 提交之后要确认的事 查看代码是否提交到线上 查看 GitHub Actions 是否已经开始工作 查看 GitHub Actions 是否工作成功 查看部署之后的网站 4.7 之后怎么更新上面的一些列流程配置好之后，以后作者就只需要 安安静静的写你的博客 （也就是 markdowm）就好了，如果需要更新，只需要使用 git 提交推送项目的源码就可以了，push会自动触发 GitHub Actions 自动构建部署 5. 实践分享 不定期更 5.1 文章图片 本地 source/images 文章资源文件夹 这样方便，但要考虑路径问题啊，文件大小问题啊 在线图床(推荐使用) 新浪已经挂了 用七牛云就是麻烦 需要搞很多事 但是弄好就很方便了 只要把图片上传后 获得一个url 就可以在 markdown中就可以直接引用 5.2 草稿文章5.2.1 默认方式新建草稿文章： 1hexo new draft &lt;title&gt; 预览草稿 ： 1hexo server --draft 将草稿发布为正式文章 1hexo publish [layout] &lt;filename&gt; 5.2.2 hexo-hide-posts 插件5.2.3 折叠文章不希望首页就把文章全部显示 这样会把首页拉的老长 可以使用 1&lt;!-- more --&gt; &lt;!-- more --&gt; 会生成一个 阅读更多的按钮， 后面的内容就不会显示在首页了 5.3 网站主题（https://hexo.io/themes/）这次我们选择的主题是 icarus 中文文档(https://blog.zhangruipeng.me/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/)","link":"/hexo-blog/2021/01/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99/"},{"title":"前端模块化","text":"为什么要有模块化 webpack认识webpack 什么是webpack 从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具 主要两点 模块 打包 前端模块化 ： 前面已经提到过为什么需要模块化 而且也提到了目前前端模块化的一些方案： AMD 、CMD、CommonJS、ES6 在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成项目后还需要处理模块间的各种依赖，并且将其进行整合打包。 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在 webpack中都可以被当作模块来使用(在后续我们会看到)。 这就是webpack中的模块化的概念 打包webpack的安装 必须先安装node webpack的起步webpack的配置1webpack ./src/main.js ./dist/bundle.js loader的使用swebpack中配置Vue1. 安装 npm 安装 1npm install vue --save ## 可以指定版本 不需要加 dev 因为运行时也需要 2. 配置Vue在开发是发布了两个版本 runtime-only -&gt; 代码中不可以有任何template runtime-compiler -》 代码中可以有template 因为有compiler 可以用于 编译template ！ 报错 vue-loader有很多版本 从14.之后就需要自己配置一个插件 可以手动改一下版本 改回到13.0.0以上的版本 用 ^13.0.0 plugin的使用插件 对现有的框架进行扩展 搭建本地服务器补充打包设置的抽离 因为开发与运行时配置不同 有的配置开发用 有的配置上线采用 所有需要将其抽离分开","link":"/hexo-blog/2021/01/03/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"","text":"详情页实现思路 一.点击商品进入详情页 GoodsListItem点击 点击之后获取商品的 iid 跳转到详情页，并且传入iid 二. 解决 - 首页 保持位置状态 ```deactivated: 记录离开时的位置 123+ ``` activated: 通过scrollTo 函数 设置离开时位置 bug： Better-Scroll 最新的1.15.0 有scrollT o 的位置 解决方法 ： 进行版本的回退 三. 详情页的导航栏实现 返回按钮 ： solt=&quot;left&quot; 标题列表 ： solt=&quot;center&quot; 四. 请求详情的数据 接口 /detail?iid 五. 轮播图的实现 Swiper/SwiperItem 六. 商品基本信息的展示 数据来自四面八方 对数据进行汇总：一个对象中 一个对象传入子组件 七. 店铺信息展示八. 商品图片的展示九. 参数信息的展示十. 评论信息的展示 时间格式化 服务器返回的时间戳 转成 date -》格式 yyyy-MM-dd hh:mm:ss 十一. 推荐数据的展示 请求推荐数据 GoodsList 展示数据 十二 , mixin 的使用 创建一个混入对象 const mixin = {} 组件对象中 ： mixins: [mixin] 十三.处理2个 bug 首页tabControl 详情滚动的bug 十四. 标题内容的联动效果14.1 点击标题滚动到对应的标题 在detail中监听标题的点击，获取index 滚动到对应的主题： 获取所有主题的offsetTop 问题：在哪里才能获取到正确的offsetTop created 肯定不行，压根不能获取数据 mounted 也不行，数据还没有获取到 获取数据的回调也不行，DOM还没有渲染完 $nextTick 也不行，因为图片的高度没有计算在内 在图片加载完成后，获取的高度才是正确的 14.2 内容滚动，显示正确的标题普通做法： 12345678(this.curentIndex !==i)&amp;&amp;((i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i=1]) || (i=== length -1 &amp;&amp; positionY &gt;= this.themeTopYs[i]))条件成立： this.currentIndex = i条件一： 防止赋值过于频繁条件二：((i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i=1]))条件1. i &lt; length -1 &amp;&amp; positionY &gt;=this.themeTopYs[i] 判断区间： 在 0 和某个数字之间 （i&lt;length - 1）条件2： i=== length -1 &amp;&amp; positionY &gt;= this.themeTopYs[i]判断大于等于： i=== length - 1 hack做法 123this.currentIndex !== i &amp;&amp; (positionY &gt;= this.themeTopYs[i] &amp;&amp; positionY &lt; this.themeTopYs[i+1])// 在数组后面加多一个 决定不会到达的值，比如 js 的最大值，或者 最后一个的几倍数// 这也就可以直接判断区间，不需要考虑最后一个 十五. 底部工具栏封装 detail-bottom-bar 十六. 详情页的回到顶部 home和detail 都有回到顶部 使用混入 mixin 十七. 点击加入购物车17.1 获取加入购物车的点击事件，并且获取商品的信息 监听 获取商品信息： iid/price/image/title… 17.2 将商品添加到vuex中 安装vuex 配置vuex 定义mutation， 将商品添加到statr.cartlist 重构代码 将mutation 抽到 actions （定义两个 mutation） 将 mutation/ actions 单独抽出到文件中 十八. 购物车的展示18.1 购物车的导航栏的展示18.2 购物车商品的展示 CartList -》 scroll（滚动问题） CartListItem -》 CheckButton 18.3 商品选中与不选中的切换 修改数据模型，改变选中与不选择 逻辑是： 修改数据模型的数据 数据发生改变 影响到视图，视图发生改变 18.4 底部工具栏的汇总 全选按钮 计算总价格 去计算按钮 十九. 购物车的全选按钮的逻辑 显示的状态 判断是否有一个不选中，就是不选中 点击全选按钮 如果原来都是选中的，点击一次，全部不选择 如果原来是不选中的或者有一个不选择，点击全部选中 二十. 添加购物车弹窗20.1 Vuex 的补充 Actions 可以返回一个Promise mapActions 映射关系 20.2 toast（吐司）封装 普通封装 插件封装 二十一. 补充一些细节21.1 fastclick 减小移动端点击的延迟 安装 fastclick 导入 调用attach 21.2 图片的懒加载 什么图片懒加载 图片需要显示到屏幕上再加载 使用 vue-lazyload 导入 Vue.use 修改 img :src 改成 v-lazy 22.3 px2vw 插件使用 安装插件 在 postcss.config.js中进行配置 面试题 如何理解Vue 的生命周期 如何进行非父子组件通信 Vue的响应式原理(初级的前端开发) 不要认为数据发生改变，界面跟着更新，并不是理所当然的 难点： 1.代码如何组织 2.业务逻辑(不要立即写代码 ，先组织逻辑)","link":"/hexo-blog/2021/01/04/%E8%AF%A6%E6%83%85%E9%A1%B5%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/hexo-blog/tags/AJAX/"},{"name":"hexo","slug":"hexo","link":"/hexo-blog/tags/hexo/"},{"name":"模块化","slug":"模块化","link":"/hexo-blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}],"categories":[{"name":"前端","slug":"前端","link":"/hexo-blog/categories/%E5%89%8D%E7%AB%AF/"}]}